{"version":3,"file":"index.js","sources":["../webpack://@oakfinch/create-heroku-app-action/./node_modules/@actions/core/lib/command.js","../webpack://@oakfinch/create-heroku-app-action/./node_modules/@actions/core/lib/core.js","../webpack://@oakfinch/create-heroku-app-action/./node_modules/@actions/core/lib/file-command.js","../webpack://@oakfinch/create-heroku-app-action/./node_modules/@actions/core/lib/oidc-utils.js","../webpack://@oakfinch/create-heroku-app-action/./node_modules/@actions/core/lib/utils.js","../webpack://@oakfinch/create-heroku-app-action/./node_modules/@actions/http-client/auth.js","../webpack://@oakfinch/create-heroku-app-action/./node_modules/@actions/http-client/index.js","../webpack://@oakfinch/create-heroku-app-action/./node_modules/@actions/http-client/proxy.js","../webpack://@oakfinch/create-heroku-app-action/./node_modules/debug/src/browser.js","../webpack://@oakfinch/create-heroku-app-action/./node_modules/debug/src/common.js","../webpack://@oakfinch/create-heroku-app-action/./node_modules/debug/src/index.js","../webpack://@oakfinch/create-heroku-app-action/./node_modules/debug/src/node.js","../webpack://@oakfinch/create-heroku-app-action/./node_modules/has-flag/index.js","../webpack://@oakfinch/create-heroku-app-action/./node_modules/heroku-client/lib/index.js","../webpack://@oakfinch/create-heroku-app-action/./node_modules/heroku-client/lib/request.js","../webpack://@oakfinch/create-heroku-app-action/./node_modules/heroku-client/lib/url.js","../webpack://@oakfinch/create-heroku-app-action/./node_modules/is-retry-allowed/index.js","../webpack://@oakfinch/create-heroku-app-action/./node_modules/ms/index.js","../webpack://@oakfinch/create-heroku-app-action/./node_modules/node-fetch-cjs/dist/index.js","../webpack://@oakfinch/create-heroku-app-action/./node_modules/safe-buffer/index.js","../webpack://@oakfinch/create-heroku-app-action/./node_modules/supports-color/index.js","../webpack://@oakfinch/create-heroku-app-action/./node_modules/tunnel-agent/index.js","../webpack://@oakfinch/create-heroku-app-action/./node_modules/tunnel/index.js","../webpack://@oakfinch/create-heroku-app-action/./node_modules/tunnel/lib/tunnel.js","../webpack://@oakfinch/create-heroku-app-action/./node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack://@oakfinch/create-heroku-app-action/external \"assert\"","../webpack://@oakfinch/create-heroku-app-action/external \"buffer\"","../webpack://@oakfinch/create-heroku-app-action/external \"events\"","../webpack://@oakfinch/create-heroku-app-action/external \"fs\"","../webpack://@oakfinch/create-heroku-app-action/external \"http\"","../webpack://@oakfinch/create-heroku-app-action/external \"https\"","../webpack://@oakfinch/create-heroku-app-action/external \"net\"","../webpack://@oakfinch/create-heroku-app-action/external \"os\"","../webpack://@oakfinch/create-heroku-app-action/external \"path\"","../webpack://@oakfinch/create-heroku-app-action/external \"process\"","../webpack://@oakfinch/create-heroku-app-action/external \"stream\"","../webpack://@oakfinch/create-heroku-app-action/external \"tls\"","../webpack://@oakfinch/create-heroku-app-action/external \"tty\"","../webpack://@oakfinch/create-heroku-app-action/external \"url\"","../webpack://@oakfinch/create-heroku-app-action/external \"util\"","../webpack://@oakfinch/create-heroku-app-action/external \"worker_threads\"","../webpack://@oakfinch/create-heroku-app-action/external \"zlib\"","../webpack://@oakfinch/create-heroku-app-action/webpack/bootstrap","../webpack://@oakfinch/create-heroku-app-action/webpack/runtime/compat","../webpack://@oakfinch/create-heroku-app-action/./index.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.issue = exports.issueCommand = void 0;\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\n/**\n * Commands\n *\n * Command Format:\n *   ::name key=value,key=value::message\n *\n * Examples:\n *   ::warning::This is the message\n *   ::set-env name=MY_VAR::some value\n */\nfunction issueCommand(command, properties, message) {\n    const cmd = new Command(command, properties, message);\n    process.stdout.write(cmd.toString() + os.EOL);\n}\nexports.issueCommand = issueCommand;\nfunction issue(name, message = '') {\n    issueCommand(name, {}, message);\n}\nexports.issue = issue;\nconst CMD_STRING = '::';\nclass Command {\n    constructor(command, properties, message) {\n        if (!command) {\n            command = 'missing.command';\n        }\n        this.command = command;\n        this.properties = properties;\n        this.message = message;\n    }\n    toString() {\n        let cmdStr = CMD_STRING + this.command;\n        if (this.properties && Object.keys(this.properties).length > 0) {\n            cmdStr += ' ';\n            let first = true;\n            for (const key in this.properties) {\n                if (this.properties.hasOwnProperty(key)) {\n                    const val = this.properties[key];\n                    if (val) {\n                        if (first) {\n                            first = false;\n                        }\n                        else {\n                            cmdStr += ',';\n                        }\n                        cmdStr += `${key}=${escapeProperty(val)}`;\n                    }\n                }\n            }\n        }\n        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;\n        return cmdStr;\n    }\n}\nfunction escapeData(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A');\n}\nfunction escapeProperty(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A')\n        .replace(/:/g, '%3A')\n        .replace(/,/g, '%2C');\n}\n//# sourceMappingURL=command.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;\nconst command_1 = require(\"./command\");\nconst file_command_1 = require(\"./file-command\");\nconst utils_1 = require(\"./utils\");\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\nconst oidc_utils_1 = require(\"./oidc-utils\");\n/**\n * The code to exit an action\n */\nvar ExitCode;\n(function (ExitCode) {\n    /**\n     * A code indicating that the action was successful\n     */\n    ExitCode[ExitCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * A code indicating that the action was a failure\n     */\n    ExitCode[ExitCode[\"Failure\"] = 1] = \"Failure\";\n})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction exportVariable(name, val) {\n    const convertedVal = utils_1.toCommandValue(val);\n    process.env[name] = convertedVal;\n    const filePath = process.env['GITHUB_ENV'] || '';\n    if (filePath) {\n        const delimiter = '_GitHubActionsFileCommandDelimeter_';\n        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;\n        file_command_1.issueCommand('ENV', commandValue);\n    }\n    else {\n        command_1.issueCommand('set-env', { name }, convertedVal);\n    }\n}\nexports.exportVariable = exportVariable;\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */\nfunction setSecret(secret) {\n    command_1.issueCommand('add-mask', {}, secret);\n}\nexports.setSecret = setSecret;\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */\nfunction addPath(inputPath) {\n    const filePath = process.env['GITHUB_PATH'] || '';\n    if (filePath) {\n        file_command_1.issueCommand('PATH', inputPath);\n    }\n    else {\n        command_1.issueCommand('add-path', {}, inputPath);\n    }\n    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;\n}\nexports.addPath = addPath;\n/**\n * Gets the value of an input.\n * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.\n * Returns an empty string if the value is not defined.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */\nfunction getInput(name, options) {\n    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';\n    if (options && options.required && !val) {\n        throw new Error(`Input required and not supplied: ${name}`);\n    }\n    if (options && options.trimWhitespace === false) {\n        return val;\n    }\n    return val.trim();\n}\nexports.getInput = getInput;\n/**\n * Gets the values of an multiline input.  Each value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string[]\n *\n */\nfunction getMultilineInput(name, options) {\n    const inputs = getInput(name, options)\n        .split('\\n')\n        .filter(x => x !== '');\n    return inputs;\n}\nexports.getMultilineInput = getMultilineInput;\n/**\n * Gets the input value of the boolean type in the YAML 1.2 \"core schema\" specification.\n * Support boolean input list: `true | True | TRUE | false | False | FALSE` .\n * The return value is also in boolean type.\n * ref: https://yaml.org/spec/1.2/spec.html#id2804923\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   boolean\n */\nfunction getBooleanInput(name, options) {\n    const trueValue = ['true', 'True', 'TRUE'];\n    const falseValue = ['false', 'False', 'FALSE'];\n    const val = getInput(name, options);\n    if (trueValue.includes(val))\n        return true;\n    if (falseValue.includes(val))\n        return false;\n    throw new TypeError(`Input does not meet YAML 1.2 \"Core Schema\" specification: ${name}\\n` +\n        `Support boolean input list: \\`true | True | TRUE | false | False | FALSE\\``);\n}\nexports.getBooleanInput = getBooleanInput;\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setOutput(name, value) {\n    process.stdout.write(os.EOL);\n    command_1.issueCommand('set-output', { name }, value);\n}\nexports.setOutput = setOutput;\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */\nfunction setCommandEcho(enabled) {\n    command_1.issue('echo', enabled ? 'on' : 'off');\n}\nexports.setCommandEcho = setCommandEcho;\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */\nfunction setFailed(message) {\n    process.exitCode = ExitCode.Failure;\n    error(message);\n}\nexports.setFailed = setFailed;\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n/**\n * Gets whether Actions Step Debug is on or not\n */\nfunction isDebug() {\n    return process.env['RUNNER_DEBUG'] === '1';\n}\nexports.isDebug = isDebug;\n/**\n * Writes debug message to user log\n * @param message debug message\n */\nfunction debug(message) {\n    command_1.issueCommand('debug', {}, message);\n}\nexports.debug = debug;\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction error(message, properties = {}) {\n    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.error = error;\n/**\n * Adds a warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction warning(message, properties = {}) {\n    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.warning = warning;\n/**\n * Adds a notice issue\n * @param message notice issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction notice(message, properties = {}) {\n    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.notice = notice;\n/**\n * Writes info to log with console.log.\n * @param message info message\n */\nfunction info(message) {\n    process.stdout.write(message + os.EOL);\n}\nexports.info = info;\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */\nfunction startGroup(name) {\n    command_1.issue('group', name);\n}\nexports.startGroup = startGroup;\n/**\n * End an output group.\n */\nfunction endGroup() {\n    command_1.issue('endgroup');\n}\nexports.endGroup = endGroup;\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */\nfunction group(name, fn) {\n    return __awaiter(this, void 0, void 0, function* () {\n        startGroup(name);\n        let result;\n        try {\n            result = yield fn();\n        }\n        finally {\n            endGroup();\n        }\n        return result;\n    });\n}\nexports.group = group;\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction saveState(name, value) {\n    command_1.issueCommand('save-state', { name }, value);\n}\nexports.saveState = saveState;\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */\nfunction getState(name) {\n    return process.env[`STATE_${name}`] || '';\n}\nexports.getState = getState;\nfunction getIDToken(aud) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield oidc_utils_1.OidcClient.getIDToken(aud);\n    });\n}\nexports.getIDToken = getIDToken;\n//# sourceMappingURL=core.js.map","\"use strict\";\n// For internal use, subject to change.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.issueCommand = void 0;\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst fs = __importStar(require(\"fs\"));\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\nfunction issueCommand(command, message) {\n    const filePath = process.env[`GITHUB_${command}`];\n    if (!filePath) {\n        throw new Error(`Unable to find environment variable for file command ${command}`);\n    }\n    if (!fs.existsSync(filePath)) {\n        throw new Error(`Missing file at path: ${filePath}`);\n    }\n    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {\n        encoding: 'utf8'\n    });\n}\nexports.issueCommand = issueCommand;\n//# sourceMappingURL=file-command.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OidcClient = void 0;\nconst http_client_1 = require(\"@actions/http-client\");\nconst auth_1 = require(\"@actions/http-client/auth\");\nconst core_1 = require(\"./core\");\nclass OidcClient {\n    static createHttpClient(allowRetry = true, maxRetry = 10) {\n        const requestOptions = {\n            allowRetries: allowRetry,\n            maxRetries: maxRetry\n        };\n        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);\n    }\n    static getRequestToken() {\n        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];\n        if (!token) {\n            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');\n        }\n        return token;\n    }\n    static getIDTokenUrl() {\n        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];\n        if (!runtimeUrl) {\n            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');\n        }\n        return runtimeUrl;\n    }\n    static getCall(id_token_url) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const httpclient = OidcClient.createHttpClient();\n            const res = yield httpclient\n                .getJson(id_token_url)\n                .catch(error => {\n                throw new Error(`Failed to get ID Token. \\n \n        Error Code : ${error.statusCode}\\n \n        Error Message: ${error.result.message}`);\n            });\n            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;\n            if (!id_token) {\n                throw new Error('Response json body do not have ID Token field');\n            }\n            return id_token;\n        });\n    }\n    static getIDToken(audience) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // New ID Token is requested from action service\n                let id_token_url = OidcClient.getIDTokenUrl();\n                if (audience) {\n                    const encodedAudience = encodeURIComponent(audience);\n                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;\n                }\n                core_1.debug(`ID token url is ${id_token_url}`);\n                const id_token = yield OidcClient.getCall(id_token_url);\n                core_1.setSecret(id_token);\n                return id_token;\n            }\n            catch (error) {\n                throw new Error(`Error message: ${error.message}`);\n            }\n        });\n    }\n}\nexports.OidcClient = OidcClient;\n//# sourceMappingURL=oidc-utils.js.map","\"use strict\";\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toCommandProperties = exports.toCommandValue = void 0;\n/**\n * Sanitizes an input into a string so it can be passed into issueCommand safely\n * @param input input to sanitize into a string\n */\nfunction toCommandValue(input) {\n    if (input === null || input === undefined) {\n        return '';\n    }\n    else if (typeof input === 'string' || input instanceof String) {\n        return input;\n    }\n    return JSON.stringify(input);\n}\nexports.toCommandValue = toCommandValue;\n/**\n *\n * @param annotationProperties\n * @returns The command properties to send with the actual annotation command\n * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646\n */\nfunction toCommandProperties(annotationProperties) {\n    if (!Object.keys(annotationProperties).length) {\n        return {};\n    }\n    return {\n        title: annotationProperties.title,\n        file: annotationProperties.file,\n        line: annotationProperties.startLine,\n        endLine: annotationProperties.endLine,\n        col: annotationProperties.startColumn,\n        endColumn: annotationProperties.endColumn\n    };\n}\nexports.toCommandProperties = toCommandProperties;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass BasicCredentialHandler {\n    constructor(username, password) {\n        this.username = username;\n        this.password = password;\n    }\n    prepareRequest(options) {\n        options.headers['Authorization'] =\n            'Basic ' +\n                Buffer.from(this.username + ':' + this.password).toString('base64');\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.BasicCredentialHandler = BasicCredentialHandler;\nclass BearerCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        options.headers['Authorization'] = 'Bearer ' + this.token;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.BearerCredentialHandler = BearerCredentialHandler;\nclass PersonalAccessTokenCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        options.headers['Authorization'] =\n            'Basic ' + Buffer.from('PAT:' + this.token).toString('base64');\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst http = require(\"http\");\nconst https = require(\"https\");\nconst pm = require(\"./proxy\");\nlet tunnel;\nvar HttpCodes;\n(function (HttpCodes) {\n    HttpCodes[HttpCodes[\"OK\"] = 200] = \"OK\";\n    HttpCodes[HttpCodes[\"MultipleChoices\"] = 300] = \"MultipleChoices\";\n    HttpCodes[HttpCodes[\"MovedPermanently\"] = 301] = \"MovedPermanently\";\n    HttpCodes[HttpCodes[\"ResourceMoved\"] = 302] = \"ResourceMoved\";\n    HttpCodes[HttpCodes[\"SeeOther\"] = 303] = \"SeeOther\";\n    HttpCodes[HttpCodes[\"NotModified\"] = 304] = \"NotModified\";\n    HttpCodes[HttpCodes[\"UseProxy\"] = 305] = \"UseProxy\";\n    HttpCodes[HttpCodes[\"SwitchProxy\"] = 306] = \"SwitchProxy\";\n    HttpCodes[HttpCodes[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n    HttpCodes[HttpCodes[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n    HttpCodes[HttpCodes[\"BadRequest\"] = 400] = \"BadRequest\";\n    HttpCodes[HttpCodes[\"Unauthorized\"] = 401] = \"Unauthorized\";\n    HttpCodes[HttpCodes[\"PaymentRequired\"] = 402] = \"PaymentRequired\";\n    HttpCodes[HttpCodes[\"Forbidden\"] = 403] = \"Forbidden\";\n    HttpCodes[HttpCodes[\"NotFound\"] = 404] = \"NotFound\";\n    HttpCodes[HttpCodes[\"MethodNotAllowed\"] = 405] = \"MethodNotAllowed\";\n    HttpCodes[HttpCodes[\"NotAcceptable\"] = 406] = \"NotAcceptable\";\n    HttpCodes[HttpCodes[\"ProxyAuthenticationRequired\"] = 407] = \"ProxyAuthenticationRequired\";\n    HttpCodes[HttpCodes[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n    HttpCodes[HttpCodes[\"Conflict\"] = 409] = \"Conflict\";\n    HttpCodes[HttpCodes[\"Gone\"] = 410] = \"Gone\";\n    HttpCodes[HttpCodes[\"TooManyRequests\"] = 429] = \"TooManyRequests\";\n    HttpCodes[HttpCodes[\"InternalServerError\"] = 500] = \"InternalServerError\";\n    HttpCodes[HttpCodes[\"NotImplemented\"] = 501] = \"NotImplemented\";\n    HttpCodes[HttpCodes[\"BadGateway\"] = 502] = \"BadGateway\";\n    HttpCodes[HttpCodes[\"ServiceUnavailable\"] = 503] = \"ServiceUnavailable\";\n    HttpCodes[HttpCodes[\"GatewayTimeout\"] = 504] = \"GatewayTimeout\";\n})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));\nvar Headers;\n(function (Headers) {\n    Headers[\"Accept\"] = \"accept\";\n    Headers[\"ContentType\"] = \"content-type\";\n})(Headers = exports.Headers || (exports.Headers = {}));\nvar MediaTypes;\n(function (MediaTypes) {\n    MediaTypes[\"ApplicationJson\"] = \"application/json\";\n})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));\n/**\n * Returns the proxy URL, depending upon the supplied url and proxy environment variables.\n * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n */\nfunction getProxyUrl(serverUrl) {\n    let proxyUrl = pm.getProxyUrl(new URL(serverUrl));\n    return proxyUrl ? proxyUrl.href : '';\n}\nexports.getProxyUrl = getProxyUrl;\nconst HttpRedirectCodes = [\n    HttpCodes.MovedPermanently,\n    HttpCodes.ResourceMoved,\n    HttpCodes.SeeOther,\n    HttpCodes.TemporaryRedirect,\n    HttpCodes.PermanentRedirect\n];\nconst HttpResponseRetryCodes = [\n    HttpCodes.BadGateway,\n    HttpCodes.ServiceUnavailable,\n    HttpCodes.GatewayTimeout\n];\nconst RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];\nconst ExponentialBackoffCeiling = 10;\nconst ExponentialBackoffTimeSlice = 5;\nclass HttpClientError extends Error {\n    constructor(message, statusCode) {\n        super(message);\n        this.name = 'HttpClientError';\n        this.statusCode = statusCode;\n        Object.setPrototypeOf(this, HttpClientError.prototype);\n    }\n}\nexports.HttpClientError = HttpClientError;\nclass HttpClientResponse {\n    constructor(message) {\n        this.message = message;\n    }\n    readBody() {\n        return new Promise(async (resolve, reject) => {\n            let output = Buffer.alloc(0);\n            this.message.on('data', (chunk) => {\n                output = Buffer.concat([output, chunk]);\n            });\n            this.message.on('end', () => {\n                resolve(output.toString());\n            });\n        });\n    }\n}\nexports.HttpClientResponse = HttpClientResponse;\nfunction isHttps(requestUrl) {\n    let parsedUrl = new URL(requestUrl);\n    return parsedUrl.protocol === 'https:';\n}\nexports.isHttps = isHttps;\nclass HttpClient {\n    constructor(userAgent, handlers, requestOptions) {\n        this._ignoreSslError = false;\n        this._allowRedirects = true;\n        this._allowRedirectDowngrade = false;\n        this._maxRedirects = 50;\n        this._allowRetries = false;\n        this._maxRetries = 1;\n        this._keepAlive = false;\n        this._disposed = false;\n        this.userAgent = userAgent;\n        this.handlers = handlers || [];\n        this.requestOptions = requestOptions;\n        if (requestOptions) {\n            if (requestOptions.ignoreSslError != null) {\n                this._ignoreSslError = requestOptions.ignoreSslError;\n            }\n            this._socketTimeout = requestOptions.socketTimeout;\n            if (requestOptions.allowRedirects != null) {\n                this._allowRedirects = requestOptions.allowRedirects;\n            }\n            if (requestOptions.allowRedirectDowngrade != null) {\n                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;\n            }\n            if (requestOptions.maxRedirects != null) {\n                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);\n            }\n            if (requestOptions.keepAlive != null) {\n                this._keepAlive = requestOptions.keepAlive;\n            }\n            if (requestOptions.allowRetries != null) {\n                this._allowRetries = requestOptions.allowRetries;\n            }\n            if (requestOptions.maxRetries != null) {\n                this._maxRetries = requestOptions.maxRetries;\n            }\n        }\n    }\n    options(requestUrl, additionalHeaders) {\n        return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});\n    }\n    get(requestUrl, additionalHeaders) {\n        return this.request('GET', requestUrl, null, additionalHeaders || {});\n    }\n    del(requestUrl, additionalHeaders) {\n        return this.request('DELETE', requestUrl, null, additionalHeaders || {});\n    }\n    post(requestUrl, data, additionalHeaders) {\n        return this.request('POST', requestUrl, data, additionalHeaders || {});\n    }\n    patch(requestUrl, data, additionalHeaders) {\n        return this.request('PATCH', requestUrl, data, additionalHeaders || {});\n    }\n    put(requestUrl, data, additionalHeaders) {\n        return this.request('PUT', requestUrl, data, additionalHeaders || {});\n    }\n    head(requestUrl, additionalHeaders) {\n        return this.request('HEAD', requestUrl, null, additionalHeaders || {});\n    }\n    sendStream(verb, requestUrl, stream, additionalHeaders) {\n        return this.request(verb, requestUrl, stream, additionalHeaders);\n    }\n    /**\n     * Gets a typed object from an endpoint\n     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise\n     */\n    async getJson(requestUrl, additionalHeaders = {}) {\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        let res = await this.get(requestUrl, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async postJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.post(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async putJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.put(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async patchJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.patch(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    /**\n     * Makes a raw http request.\n     * All other methods such as get, post, patch, and request ultimately call this.\n     * Prefer get, del, post and patch\n     */\n    async request(verb, requestUrl, data, headers) {\n        if (this._disposed) {\n            throw new Error('Client has already been disposed.');\n        }\n        let parsedUrl = new URL(requestUrl);\n        let info = this._prepareRequest(verb, parsedUrl, headers);\n        // Only perform retries on reads since writes may not be idempotent.\n        let maxTries = this._allowRetries && RetryableHttpVerbs.indexOf(verb) != -1\n            ? this._maxRetries + 1\n            : 1;\n        let numTries = 0;\n        let response;\n        while (numTries < maxTries) {\n            response = await this.requestRaw(info, data);\n            // Check if it's an authentication challenge\n            if (response &&\n                response.message &&\n                response.message.statusCode === HttpCodes.Unauthorized) {\n                let authenticationHandler;\n                for (let i = 0; i < this.handlers.length; i++) {\n                    if (this.handlers[i].canHandleAuthentication(response)) {\n                        authenticationHandler = this.handlers[i];\n                        break;\n                    }\n                }\n                if (authenticationHandler) {\n                    return authenticationHandler.handleAuthentication(this, info, data);\n                }\n                else {\n                    // We have received an unauthorized response but have no handlers to handle it.\n                    // Let the response return to the caller.\n                    return response;\n                }\n            }\n            let redirectsRemaining = this._maxRedirects;\n            while (HttpRedirectCodes.indexOf(response.message.statusCode) != -1 &&\n                this._allowRedirects &&\n                redirectsRemaining > 0) {\n                const redirectUrl = response.message.headers['location'];\n                if (!redirectUrl) {\n                    // if there's no location to redirect to, we won't\n                    break;\n                }\n                let parsedRedirectUrl = new URL(redirectUrl);\n                if (parsedUrl.protocol == 'https:' &&\n                    parsedUrl.protocol != parsedRedirectUrl.protocol &&\n                    !this._allowRedirectDowngrade) {\n                    throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');\n                }\n                // we need to finish reading the response before reassigning response\n                // which will leak the open socket.\n                await response.readBody();\n                // strip authorization header if redirected to a different hostname\n                if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {\n                    for (let header in headers) {\n                        // header names are case insensitive\n                        if (header.toLowerCase() === 'authorization') {\n                            delete headers[header];\n                        }\n                    }\n                }\n                // let's make the request with the new redirectUrl\n                info = this._prepareRequest(verb, parsedRedirectUrl, headers);\n                response = await this.requestRaw(info, data);\n                redirectsRemaining--;\n            }\n            if (HttpResponseRetryCodes.indexOf(response.message.statusCode) == -1) {\n                // If not a retry code, return immediately instead of retrying\n                return response;\n            }\n            numTries += 1;\n            if (numTries < maxTries) {\n                await response.readBody();\n                await this._performExponentialBackoff(numTries);\n            }\n        }\n        return response;\n    }\n    /**\n     * Needs to be called if keepAlive is set to true in request options.\n     */\n    dispose() {\n        if (this._agent) {\n            this._agent.destroy();\n        }\n        this._disposed = true;\n    }\n    /**\n     * Raw request.\n     * @param info\n     * @param data\n     */\n    requestRaw(info, data) {\n        return new Promise((resolve, reject) => {\n            let callbackForResult = function (err, res) {\n                if (err) {\n                    reject(err);\n                }\n                resolve(res);\n            };\n            this.requestRawWithCallback(info, data, callbackForResult);\n        });\n    }\n    /**\n     * Raw request with callback.\n     * @param info\n     * @param data\n     * @param onResult\n     */\n    requestRawWithCallback(info, data, onResult) {\n        let socket;\n        if (typeof data === 'string') {\n            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');\n        }\n        let callbackCalled = false;\n        let handleResult = (err, res) => {\n            if (!callbackCalled) {\n                callbackCalled = true;\n                onResult(err, res);\n            }\n        };\n        let req = info.httpModule.request(info.options, (msg) => {\n            let res = new HttpClientResponse(msg);\n            handleResult(null, res);\n        });\n        req.on('socket', sock => {\n            socket = sock;\n        });\n        // If we ever get disconnected, we want the socket to timeout eventually\n        req.setTimeout(this._socketTimeout || 3 * 60000, () => {\n            if (socket) {\n                socket.end();\n            }\n            handleResult(new Error('Request timeout: ' + info.options.path), null);\n        });\n        req.on('error', function (err) {\n            // err has statusCode property\n            // res should have headers\n            handleResult(err, null);\n        });\n        if (data && typeof data === 'string') {\n            req.write(data, 'utf8');\n        }\n        if (data && typeof data !== 'string') {\n            data.on('close', function () {\n                req.end();\n            });\n            data.pipe(req);\n        }\n        else {\n            req.end();\n        }\n    }\n    /**\n     * Gets an http agent. This function is useful when you need an http agent that handles\n     * routing through a proxy server - depending upon the url and proxy environment variables.\n     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n     */\n    getAgent(serverUrl) {\n        let parsedUrl = new URL(serverUrl);\n        return this._getAgent(parsedUrl);\n    }\n    _prepareRequest(method, requestUrl, headers) {\n        const info = {};\n        info.parsedUrl = requestUrl;\n        const usingSsl = info.parsedUrl.protocol === 'https:';\n        info.httpModule = usingSsl ? https : http;\n        const defaultPort = usingSsl ? 443 : 80;\n        info.options = {};\n        info.options.host = info.parsedUrl.hostname;\n        info.options.port = info.parsedUrl.port\n            ? parseInt(info.parsedUrl.port)\n            : defaultPort;\n        info.options.path =\n            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');\n        info.options.method = method;\n        info.options.headers = this._mergeHeaders(headers);\n        if (this.userAgent != null) {\n            info.options.headers['user-agent'] = this.userAgent;\n        }\n        info.options.agent = this._getAgent(info.parsedUrl);\n        // gives handlers an opportunity to participate\n        if (this.handlers) {\n            this.handlers.forEach(handler => {\n                handler.prepareRequest(info.options);\n            });\n        }\n        return info;\n    }\n    _mergeHeaders(headers) {\n        const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});\n        if (this.requestOptions && this.requestOptions.headers) {\n            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers));\n        }\n        return lowercaseKeys(headers || {});\n    }\n    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {\n        const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});\n        let clientHeader;\n        if (this.requestOptions && this.requestOptions.headers) {\n            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];\n        }\n        return additionalHeaders[header] || clientHeader || _default;\n    }\n    _getAgent(parsedUrl) {\n        let agent;\n        let proxyUrl = pm.getProxyUrl(parsedUrl);\n        let useProxy = proxyUrl && proxyUrl.hostname;\n        if (this._keepAlive && useProxy) {\n            agent = this._proxyAgent;\n        }\n        if (this._keepAlive && !useProxy) {\n            agent = this._agent;\n        }\n        // if agent is already assigned use that agent.\n        if (!!agent) {\n            return agent;\n        }\n        const usingSsl = parsedUrl.protocol === 'https:';\n        let maxSockets = 100;\n        if (!!this.requestOptions) {\n            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;\n        }\n        if (useProxy) {\n            // If using proxy, need tunnel\n            if (!tunnel) {\n                tunnel = require('tunnel');\n            }\n            const agentOptions = {\n                maxSockets: maxSockets,\n                keepAlive: this._keepAlive,\n                proxy: {\n                    ...((proxyUrl.username || proxyUrl.password) && {\n                        proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`\n                    }),\n                    host: proxyUrl.hostname,\n                    port: proxyUrl.port\n                }\n            };\n            let tunnelAgent;\n            const overHttps = proxyUrl.protocol === 'https:';\n            if (usingSsl) {\n                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;\n            }\n            else {\n                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;\n            }\n            agent = tunnelAgent(agentOptions);\n            this._proxyAgent = agent;\n        }\n        // if reusing agent across request and tunneling agent isn't assigned create a new agent\n        if (this._keepAlive && !agent) {\n            const options = { keepAlive: this._keepAlive, maxSockets: maxSockets };\n            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);\n            this._agent = agent;\n        }\n        // if not using private agent and tunnel agent isn't setup then use global agent\n        if (!agent) {\n            agent = usingSsl ? https.globalAgent : http.globalAgent;\n        }\n        if (usingSsl && this._ignoreSslError) {\n            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process\n            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options\n            // we have to cast it to any and change it directly\n            agent.options = Object.assign(agent.options || {}, {\n                rejectUnauthorized: false\n            });\n        }\n        return agent;\n    }\n    _performExponentialBackoff(retryNumber) {\n        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);\n        const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);\n        return new Promise(resolve => setTimeout(() => resolve(), ms));\n    }\n    static dateTimeDeserializer(key, value) {\n        if (typeof value === 'string') {\n            let a = new Date(value);\n            if (!isNaN(a.valueOf())) {\n                return a;\n            }\n        }\n        return value;\n    }\n    async _processResponse(res, options) {\n        return new Promise(async (resolve, reject) => {\n            const statusCode = res.message.statusCode;\n            const response = {\n                statusCode: statusCode,\n                result: null,\n                headers: {}\n            };\n            // not found leads to null obj returned\n            if (statusCode == HttpCodes.NotFound) {\n                resolve(response);\n            }\n            let obj;\n            let contents;\n            // get the result from the body\n            try {\n                contents = await res.readBody();\n                if (contents && contents.length > 0) {\n                    if (options && options.deserializeDates) {\n                        obj = JSON.parse(contents, HttpClient.dateTimeDeserializer);\n                    }\n                    else {\n                        obj = JSON.parse(contents);\n                    }\n                    response.result = obj;\n                }\n                response.headers = res.message.headers;\n            }\n            catch (err) {\n                // Invalid resource (contents not json);  leaving result obj null\n            }\n            // note that 3xx redirects are handled by the http layer.\n            if (statusCode > 299) {\n                let msg;\n                // if exception/error in body, attempt to get better error\n                if (obj && obj.message) {\n                    msg = obj.message;\n                }\n                else if (contents && contents.length > 0) {\n                    // it may be the case that the exception is in the body message as string\n                    msg = contents;\n                }\n                else {\n                    msg = 'Failed request: (' + statusCode + ')';\n                }\n                let err = new HttpClientError(msg, statusCode);\n                err.result = response.result;\n                reject(err);\n            }\n            else {\n                resolve(response);\n            }\n        });\n    }\n}\nexports.HttpClient = HttpClient;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getProxyUrl(reqUrl) {\n    let usingSsl = reqUrl.protocol === 'https:';\n    let proxyUrl;\n    if (checkBypass(reqUrl)) {\n        return proxyUrl;\n    }\n    let proxyVar;\n    if (usingSsl) {\n        proxyVar = process.env['https_proxy'] || process.env['HTTPS_PROXY'];\n    }\n    else {\n        proxyVar = process.env['http_proxy'] || process.env['HTTP_PROXY'];\n    }\n    if (proxyVar) {\n        proxyUrl = new URL(proxyVar);\n    }\n    return proxyUrl;\n}\nexports.getProxyUrl = getProxyUrl;\nfunction checkBypass(reqUrl) {\n    if (!reqUrl.hostname) {\n        return false;\n    }\n    let noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';\n    if (!noProxy) {\n        return false;\n    }\n    // Determine the request port\n    let reqPort;\n    if (reqUrl.port) {\n        reqPort = Number(reqUrl.port);\n    }\n    else if (reqUrl.protocol === 'http:') {\n        reqPort = 80;\n    }\n    else if (reqUrl.protocol === 'https:') {\n        reqPort = 443;\n    }\n    // Format the request hostname and hostname with port\n    let upperReqHosts = [reqUrl.hostname.toUpperCase()];\n    if (typeof reqPort === 'number') {\n        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);\n    }\n    // Compare request host against noproxy\n    for (let upperNoProxyItem of noProxy\n        .split(',')\n        .map(x => x.trim().toUpperCase())\n        .filter(x => x)) {\n        if (upperReqHosts.some(x => x === upperNoProxyItem)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.checkBypass = checkBypass;\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {\n\tmodule.exports = require('./browser.js');\n} else {\n\tmodule.exports = require('./node.js');\n}\n","/**\n * Module dependencies.\n */\n\nconst tty = require('tty');\nconst util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(\n\t() => {},\n\t'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'\n);\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n\t// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n\t// eslint-disable-next-line import/no-extraneous-dependencies\n\tconst supportsColor = require('supports-color');\n\n\tif (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n\t\texports.colors = [\n\t\t\t20,\n\t\t\t21,\n\t\t\t26,\n\t\t\t27,\n\t\t\t32,\n\t\t\t33,\n\t\t\t38,\n\t\t\t39,\n\t\t\t40,\n\t\t\t41,\n\t\t\t42,\n\t\t\t43,\n\t\t\t44,\n\t\t\t45,\n\t\t\t56,\n\t\t\t57,\n\t\t\t62,\n\t\t\t63,\n\t\t\t68,\n\t\t\t69,\n\t\t\t74,\n\t\t\t75,\n\t\t\t76,\n\t\t\t77,\n\t\t\t78,\n\t\t\t79,\n\t\t\t80,\n\t\t\t81,\n\t\t\t92,\n\t\t\t93,\n\t\t\t98,\n\t\t\t99,\n\t\t\t112,\n\t\t\t113,\n\t\t\t128,\n\t\t\t129,\n\t\t\t134,\n\t\t\t135,\n\t\t\t148,\n\t\t\t149,\n\t\t\t160,\n\t\t\t161,\n\t\t\t162,\n\t\t\t163,\n\t\t\t164,\n\t\t\t165,\n\t\t\t166,\n\t\t\t167,\n\t\t\t168,\n\t\t\t169,\n\t\t\t170,\n\t\t\t171,\n\t\t\t172,\n\t\t\t173,\n\t\t\t178,\n\t\t\t179,\n\t\t\t184,\n\t\t\t185,\n\t\t\t196,\n\t\t\t197,\n\t\t\t198,\n\t\t\t199,\n\t\t\t200,\n\t\t\t201,\n\t\t\t202,\n\t\t\t203,\n\t\t\t204,\n\t\t\t205,\n\t\t\t206,\n\t\t\t207,\n\t\t\t208,\n\t\t\t209,\n\t\t\t214,\n\t\t\t215,\n\t\t\t220,\n\t\t\t221\n\t\t];\n\t}\n} catch (error) {\n\t// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n\treturn /^debug_/i.test(key);\n}).reduce((obj, key) => {\n\t// Camel-case\n\tconst prop = key\n\t\t.substring(6)\n\t\t.toLowerCase()\n\t\t.replace(/_([a-z])/g, (_, k) => {\n\t\t\treturn k.toUpperCase();\n\t\t});\n\n\t// Coerce string value into JS value\n\tlet val = process.env[key];\n\tif (/^(yes|on|true|enabled)$/i.test(val)) {\n\t\tval = true;\n\t} else if (/^(no|off|false|disabled)$/i.test(val)) {\n\t\tval = false;\n\t} else if (val === 'null') {\n\t\tval = null;\n\t} else {\n\t\tval = Number(val);\n\t}\n\n\tobj[prop] = val;\n\treturn obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n\treturn 'colors' in exports.inspectOpts ?\n\t\tBoolean(exports.inspectOpts.colors) :\n\t\ttty.isatty(process.stderr.fd);\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\tconst {namespace: name, useColors} = this;\n\n\tif (useColors) {\n\t\tconst c = this.color;\n\t\tconst colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n\t\tconst prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n\n\t\targs[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n\t\targs.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n\t} else {\n\t\targs[0] = getDate() + name + ' ' + args[0];\n\t}\n}\n\nfunction getDate() {\n\tif (exports.inspectOpts.hideDate) {\n\t\treturn '';\n\t}\n\treturn new Date().toISOString() + ' ';\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\nfunction log(...args) {\n\treturn process.stderr.write(util.format(...args) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\tif (namespaces) {\n\t\tprocess.env.DEBUG = namespaces;\n\t} else {\n\t\t// If you set a process.env field to null or undefined, it gets cast to the\n\t\t// string 'null' or 'undefined'. Just delete instead.\n\t\tdelete process.env.DEBUG;\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n\treturn process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n\tdebug.inspectOpts = {};\n\n\tconst keys = Object.keys(exports.inspectOpts);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tdebug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts)\n\t\t.split('\\n')\n\t\t.map(str => str.trim())\n\t\t.join(' ');\n};\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\nformatters.O = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts);\n};\n","'use strict';\n\nmodule.exports = (flag, argv = process.argv) => {\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst position = argv.indexOf(prefix + flag);\n\tconst terminatorPosition = argv.indexOf('--');\n\treturn position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);\n};\n","'use strict'\n\nclass Heroku {\n  constructor (options) {\n    this.options = options || {}\n  }\n\n  request (options) {\n    var Request = require('./request')\n    options = options || {}\n    options.headers = Object.assign(Object.assign({}, this.options.headers), options.headers)\n    options = Object.assign({}, this.options, options)\n    let request = new Request(options)\n    return request.request()\n  }\n\n  get (path, options) {\n    return this.request(Object.assign({}, options, {method: 'GET', path: path}))\n  }\n\n  put (path, options) {\n    return this.request(Object.assign({}, options, {method: 'PUT', path: path}))\n  }\n\n  post (path, options) {\n    return this.request(Object.assign({}, options, {method: 'POST', path: path}))\n  }\n\n  patch (path, options) {\n    return this.request(Object.assign({}, options, {method: 'PATCH', path: path}))\n  }\n\n  delete (path, options) {\n    return this.request(Object.assign({}, options, {method: 'DELETE', path: path}))\n  }\n}\n\nmodule.exports = Heroku\n","'use strict'\n\nlet _debugHeaders\nfunction debugHeaders () {\n  try {\n    if (!_debugHeaders) _debugHeaders = require('debug')('http')\n    _debugHeaders.apply(null, Array.prototype.slice.call(arguments))\n  } catch (err) {}\n}\n\nlet _debug\nfunction debug () {\n  try {\n    if (!_debug) _debug = require('debug')('http')\n    _debug.apply(null, Array.prototype.slice.call(arguments))\n  } catch (err) {}\n}\n\n/*\n * Object capable of making API calls.\n */\nclass Request {\n  constructor (options) {\n    var URL = require('./url')\n\n    this.options = options || {}\n    this.debug = options.debug\n    this.debugHeaders = options.debugHeaders\n    var url = URL(options.host || 'https://api.heroku.com')\n    this.host = url.host\n    this.port = url.port\n    this.secure = url.secure\n    this.partial = options.partial\n    this.userAgent = options.userAgent\n    if (!this.userAgent) {\n      var pjson = require('../package.json')\n      this.userAgent = 'node-heroku-client/' + pjson.version\n    }\n    this.parseJSON = options.hasOwnProperty('parseJSON') ? options.parseJSON : true\n    this.nextRange = 'id ..; max=1000'\n    this.logger = options.logger\n    this.middleware = options.middleware || function (_, cb) { cb() }\n    this.certs = getCerts(this.debug)\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve\n      this.reject = reject\n    })\n    if (process.env.HEROKU_HTTP_PROXY_HOST) {\n      var tunnel = require('tunnel-agent')\n      var tunnelFunc\n      if (this.secure) {\n        tunnelFunc = tunnel.httpsOverHttp\n      } else {\n        tunnelFunc = tunnel.httpOverHttp\n      }\n      var agentOpts = {\n        proxy: {\n          host: process.env.HEROKU_HTTP_PROXY_HOST,\n          port: process.env.HEROKU_HTTP_PROXY_PORT || 8080,\n          proxyAuth: process.env.HEROKU_HTTP_PROXY_AUTH\n        },\n        rejectUnauthorized: options.rejectUnauthorized\n      }\n      if (this.certs.length > 0) {\n        agentOpts.ca = this.certs\n      }\n      this.agent = tunnelFunc(agentOpts)\n    } else {\n      if (this.secure) {\n        var https = require('https')\n        this.agent = new https.Agent({ maxSockets: Number(process.env.HEROKU_CLIENT_MAX_SOCKETS) || 5000 })\n      } else {\n        var http = require('http')\n        this.agent = new http.Agent({ maxSockets: Number(process.env.HEROKU_CLIENT_MAX_SOCKETS) || 5000 })\n      }\n    }\n  }\n\n  /*\n   * Perform the actual API request.\n   */\n  request () {\n    var headers = Object.assign({\n      'Accept': 'application/vnd.heroku+json; version=3',\n      'Content-type': 'application/json',\n      'User-Agent': this.userAgent,\n      'Range': this.nextRange\n    }, this.options.headers)\n    // remove null|undefined headers\n    for (var k in Object.keys(headers)) {\n      if (headers[k] === null || headers[k] === undefined) {\n        delete headers[k]\n      }\n    }\n\n    var requestOptions = {\n      agent: this.agent,\n      host: this.host,\n      port: this.port,\n      path: this.options.path,\n      auth: this.options.auth || ':' + this.options.token,\n      method: this.options.method || 'GET',\n      rejectUnauthorized: this.options.rejectUnauthorized,\n      headers: headers\n    }\n    if (this.certs.length > 0) {\n      requestOptions.ca = this.certs\n    }\n\n    let req\n    if (this.secure) {\n      var https = require('https')\n      req = https.request(requestOptions, this.handleResponse.bind(this))\n    } else {\n      var http = require('http')\n      req = http.request(requestOptions, this.handleResponse.bind(this))\n    }\n\n    this.logRequest(req)\n    this.writeBody(req)\n    this.setRequestTimeout(req)\n\n    req.on('error', this.handleError.bind(this))\n\n    req.end()\n\n    return this.promise\n  }\n\n  /*\n   * Handle an API response, returning the API response.\n   */\n  handleResponse (res) {\n    this.middleware(res, () => {\n      this.logResponse(res)\n      if (res.statusCode === 304) {\n        this.updateAggregate(this.cachedResponse.body)\n        this.resolve(this.aggregate)\n        return\n      }\n      concat(res).then((data) => {\n        debug(`<-- ${this.options.method} ${this.options.path}\\n${data}`)\n        debugHeaders('\\n' + renderHeaders(res.headers))\n        if (this.debug) console.error('<-- ' + data)\n        if (res.statusCode.toString().match(/^2\\d{2}$/)) {\n          this.handleSuccess(res, data)\n        } else {\n          this.handleFailure(res, data)\n        }\n      }).catch(this.reject)\n    })\n  }\n\n  isRetryAllowed (error) {\n    const isRetryAllowed = require('is-retry-allowed')\n    if (!isRetryAllowed(error)) return false\n    if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) return false\n    return true\n  }\n\n  handleError (error) {\n    if (!this.retries) this.retries = 0\n    if (this.retries >= 4 || !this.isRetryAllowed(error)) return this.reject(error)\n    let noise = Math.random() * 100\n    setTimeout(() => this.request(), (1 << this.retries) * 1000 + noise)\n    this.retries++\n  }\n\n  logRequest (req) {\n    debug(`--> ${req.method} ${this.options.path}`)\n    if (this.debug) console.error('--> ' + req.method + ' ' + req.path)\n    let reqHeaders = req.getHeaders ? req.getHeaders() : req._headers // .getHeaders isn't defined in node versions < 8\n    if (!reqHeaders) return\n    let headers = renderHeaders(reqHeaders)\n    debugHeaders('\\n' + headers)\n    if (this.debugHeaders) console.error(headers)\n  }\n\n  /*\n   * Log the API response.\n   */\n  logResponse (res) {\n    if (this.logger) {\n      this.logger.log({\n        status: res.statusCode,\n        content_length: res.headers['content-length'],\n        request_id: res.headers['request-id']\n      })\n    }\n    let headers = renderHeaders(res.headers)\n    if (this.debug) console.error('<-- ' + res.statusCode + ' ' + res.statusMessage)\n    if (this.debugHeaders) console.error(headers)\n  }\n\n  /*\n   * If the request options include a body,\n   * write the body to the request and set\n   * an appropriate 'Content-length' header.\n   */\n  writeBody (req) {\n    if (this.options.body) {\n      var body = this.options.body\n      if (this.options.json !== false) { body = JSON.stringify(body) }\n      if (this.debug) {\n        console.error('--> ' + body)\n      }\n\n      req.setHeader('Content-length', Buffer.byteLength(body, 'utf8'))\n      req.write(body)\n    } else {\n      req.setHeader('Content-length', 0)\n    }\n  }\n\n  /*\n   * If the request options include a timeout,\n   * set the timeout and provide a callback\n   * function in case the request exceeds the\n   * timeout period.\n   */\n  setRequestTimeout (req) {\n    if (!this.options.timeout) return\n\n    req.setTimeout(this.options.timeout, () => {\n      var err = new Error('Request took longer than ' + this.options.timeout + 'ms to complete.')\n\n      req.abort()\n\n      this.reject(err)\n    })\n  }\n\n  /*\n   * Get the request body, and parse it (or not) as appropriate.\n   * - Parse JSON by default.\n   * - If parseJSON is `false`, it will not parse.\n   */\n  parseBody (body) {\n    if (this.parseJSON) {\n      return JSON.parse(body || '{}')\n    } else {\n      return body\n    }\n  }\n\n  /*\n   * In the event of a non-successful API request,\n   * fail with an appropriate error message and\n   * status code.\n   */\n  handleFailure (res, buffer) {\n    var message = 'Expected response to be successful, got ' + res.statusCode\n    var err\n\n    err = new Error(message)\n    err.statusCode = res.statusCode\n    try {\n      err.body = this.parseBody(buffer)\n    } catch (e) {\n      err.body = buffer\n    }\n\n    this.reject(err)\n  }\n\n  /*\n   * In the event of a successful API response,\n   * respond with the response body.\n   */\n  handleSuccess (res, buffer) {\n    var body = this.parseBody(buffer)\n\n    if (!this.partial && res.headers['next-range']) {\n      this.nextRequest(res.headers['next-range'], body)\n    } else {\n      this.updateAggregate(body)\n      this.resolve(this.aggregate)\n    }\n  }\n\n  /*\n   * Since this request isn't the full response (206 or\n   * 304 with a cached Next-Range), perform the next\n   * request for more data.\n   */\n  nextRequest (nextRange, body) {\n    this.updateAggregate(body)\n    this.nextRange = nextRange\n    // The initial range header passed in (if there was one), is no longer valid, and should no longer take precedence\n    delete (this.options.headers.Range)\n    this.request()\n  }\n\n  /*\n   * If given an object, sets aggregate to object,\n   * otherwise concats array onto aggregate.\n   */\n  updateAggregate (aggregate) {\n    if (aggregate instanceof Array) {\n      this.aggregate = this.aggregate || []\n      this.aggregate = this.aggregate.concat(aggregate)\n    } else {\n      this.aggregate = aggregate\n    }\n  }\n}\n\nfunction sslCertFile () {\n  return process.env.SSL_CERT_FILE ? [process.env.SSL_CERT_FILE] : []\n}\n\nfunction sslCertDir () {\n  var certDir = process.env.SSL_CERT_DIR\n  if (certDir) {\n    var path = require('path')\n    var fs = require('fs')\n    return fs.readdirSync(certDir)\n      .map((f) => path.join(certDir, f))\n      .filter((f) => fs.statSync(f).isFile())\n  } else {\n    return []\n  }\n}\n\nfunction getCerts (debug) {\n  var filenames = sslCertFile().concat(sslCertDir())\n\n  if (filenames.length > 0 && debug) {\n    console.error('Adding the following trusted certificate authorities')\n  }\n\n  return filenames.map(function (filename) {\n    var fs = require('fs')\n    if (debug) {\n      console.error('  ' + filename)\n    }\n    return fs.readFileSync(filename)\n  })\n}\n\nfunction renderHeaders (headers) {\n  return Object.keys(headers).map(key => {\n    let value = key.toUpperCase() === 'AUTHORIZATION' ? 'REDACTED' : headers[key]\n    return '    ' + key + '=' + value\n  }).join('\\n')\n}\n\nfunction concat (stream) {\n  return new Promise((resolve) => {\n    var strings = []\n    stream.on('data', (data) => strings.push(data))\n    stream.on('end', () => resolve(strings.join('')))\n  })\n}\n\nmodule.exports = Request\n","'use strict'\n\nvar url = require('url')\n\nmodule.exports = function (u) {\n  if (u.indexOf('http') !== 0 && u.indexOf('https') !== 0) {\n    u = 'https://' + u\n  }\n\n  var uu = url.parse(u)\n  var port = uu.port\n  if (!port) {\n    if (uu.protocol === 'https:') {\n      port = '443'\n    } else {\n      port = '80'\n    }\n  }\n  var secure = uu.protocol === 'https:' || uu.port === '443'\n\n  return { host: uu.hostname, port: parseInt(port), secure: secure }\n}\n","'use strict';\n\nvar WHITELIST = [\n\t'ETIMEDOUT',\n\t'ECONNRESET',\n\t'EADDRINUSE',\n\t'ESOCKETTIMEDOUT',\n\t'ECONNREFUSED',\n\t'EPIPE',\n\t'EHOSTUNREACH',\n\t'EAI_AGAIN'\n];\n\nvar BLACKLIST = [\n\t'ENOTFOUND',\n\t'ENETUNREACH',\n\n\t// SSL errors from https://github.com/nodejs/node/blob/ed3d8b13ee9a705d89f9e0397d9e96519e7e47ac/src/node_crypto.cc#L1950\n\t'UNABLE_TO_GET_ISSUER_CERT',\n\t'UNABLE_TO_GET_CRL',\n\t'UNABLE_TO_DECRYPT_CERT_SIGNATURE',\n\t'UNABLE_TO_DECRYPT_CRL_SIGNATURE',\n\t'UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY',\n\t'CERT_SIGNATURE_FAILURE',\n\t'CRL_SIGNATURE_FAILURE',\n\t'CERT_NOT_YET_VALID',\n\t'CERT_HAS_EXPIRED',\n\t'CRL_NOT_YET_VALID',\n\t'CRL_HAS_EXPIRED',\n\t'ERROR_IN_CERT_NOT_BEFORE_FIELD',\n\t'ERROR_IN_CERT_NOT_AFTER_FIELD',\n\t'ERROR_IN_CRL_LAST_UPDATE_FIELD',\n\t'ERROR_IN_CRL_NEXT_UPDATE_FIELD',\n\t'OUT_OF_MEM',\n\t'DEPTH_ZERO_SELF_SIGNED_CERT',\n\t'SELF_SIGNED_CERT_IN_CHAIN',\n\t'UNABLE_TO_GET_ISSUER_CERT_LOCALLY',\n\t'UNABLE_TO_VERIFY_LEAF_SIGNATURE',\n\t'CERT_CHAIN_TOO_LONG',\n\t'CERT_REVOKED',\n\t'INVALID_CA',\n\t'PATH_LENGTH_EXCEEDED',\n\t'INVALID_PURPOSE',\n\t'CERT_UNTRUSTED',\n\t'CERT_REJECTED'\n];\n\nmodule.exports = function (err) {\n\tif (!err || !err.code) {\n\t\treturn true;\n\t}\n\n\tif (WHITELIST.indexOf(err.code) !== -1) {\n\t\treturn true;\n\t}\n\n\tif (BLACKLIST.indexOf(err.code) !== -1) {\n\t\treturn false;\n\t}\n\n\treturn true;\n};\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;\n};\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n\n// node_modules/web-streams-polyfill/dist/ponyfill.es2018.js\nvar require_ponyfill_es2018 = __commonJS({\n  \"node_modules/web-streams-polyfill/dist/ponyfill.es2018.js\"(exports, module2) {\n    (function(global2, factory) {\n      typeof exports === \"object\" && typeof module2 !== \"undefined\" ? factory(exports) : typeof define === \"function\" && define.amd ? define([\"exports\"], factory) : (global2 = typeof globalThis !== \"undefined\" ? globalThis : global2 || self, factory(global2.WebStreamsPolyfill = {}));\n    })(exports, function(exports2) {\n      \"use strict\";\n      const SymbolPolyfill = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? Symbol : (description) => `Symbol(${description})`;\n      function noop2() {\n        return void 0;\n      }\n      function getGlobals() {\n        if (typeof self !== \"undefined\") {\n          return self;\n        } else if (typeof window !== \"undefined\") {\n          return window;\n        } else if (typeof global !== \"undefined\") {\n          return global;\n        }\n        return void 0;\n      }\n      const globals = getGlobals();\n      function typeIsObject(x2) {\n        return typeof x2 === \"object\" && x2 !== null || typeof x2 === \"function\";\n      }\n      const rethrowAssertionErrorRejection = noop2;\n      const originalPromise = Promise;\n      const originalPromiseThen = Promise.prototype.then;\n      const originalPromiseResolve = Promise.resolve.bind(originalPromise);\n      const originalPromiseReject = Promise.reject.bind(originalPromise);\n      function newPromise(executor) {\n        return new originalPromise(executor);\n      }\n      function promiseResolvedWith(value) {\n        return originalPromiseResolve(value);\n      }\n      function promiseRejectedWith(reason) {\n        return originalPromiseReject(reason);\n      }\n      function PerformPromiseThen(promise, onFulfilled, onRejected) {\n        return originalPromiseThen.call(promise, onFulfilled, onRejected);\n      }\n      function uponPromise(promise, onFulfilled, onRejected) {\n        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);\n      }\n      function uponFulfillment(promise, onFulfilled) {\n        uponPromise(promise, onFulfilled);\n      }\n      function uponRejection(promise, onRejected) {\n        uponPromise(promise, void 0, onRejected);\n      }\n      function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {\n        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n      }\n      function setPromiseIsHandledToTrue(promise) {\n        PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);\n      }\n      const queueMicrotask = (() => {\n        const globalQueueMicrotask = globals && globals.queueMicrotask;\n        if (typeof globalQueueMicrotask === \"function\") {\n          return globalQueueMicrotask;\n        }\n        const resolvedPromise = promiseResolvedWith(void 0);\n        return (fn) => PerformPromiseThen(resolvedPromise, fn);\n      })();\n      function reflectCall(F2, V, args) {\n        if (typeof F2 !== \"function\") {\n          throw new TypeError(\"Argument is not a function\");\n        }\n        return Function.prototype.apply.call(F2, V, args);\n      }\n      function promiseCall(F2, V, args) {\n        try {\n          return promiseResolvedWith(reflectCall(F2, V, args));\n        } catch (value) {\n          return promiseRejectedWith(value);\n        }\n      }\n      const QUEUE_MAX_ARRAY_SIZE = 16384;\n      class SimpleQueue {\n        constructor() {\n          this._cursor = 0;\n          this._size = 0;\n          this._front = {\n            _elements: [],\n            _next: void 0\n          };\n          this._back = this._front;\n          this._cursor = 0;\n          this._size = 0;\n        }\n        get length() {\n          return this._size;\n        }\n        push(element) {\n          const oldBack = this._back;\n          let newBack = oldBack;\n          if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n            newBack = {\n              _elements: [],\n              _next: void 0\n            };\n          }\n          oldBack._elements.push(element);\n          if (newBack !== oldBack) {\n            this._back = newBack;\n            oldBack._next = newBack;\n          }\n          ++this._size;\n        }\n        shift() {\n          const oldFront = this._front;\n          let newFront = oldFront;\n          const oldCursor = this._cursor;\n          let newCursor = oldCursor + 1;\n          const elements = oldFront._elements;\n          const element = elements[oldCursor];\n          if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n            newFront = oldFront._next;\n            newCursor = 0;\n          }\n          --this._size;\n          this._cursor = newCursor;\n          if (oldFront !== newFront) {\n            this._front = newFront;\n          }\n          elements[oldCursor] = void 0;\n          return element;\n        }\n        forEach(callback) {\n          let i2 = this._cursor;\n          let node = this._front;\n          let elements = node._elements;\n          while (i2 !== elements.length || node._next !== void 0) {\n            if (i2 === elements.length) {\n              node = node._next;\n              elements = node._elements;\n              i2 = 0;\n              if (elements.length === 0) {\n                break;\n              }\n            }\n            callback(elements[i2]);\n            ++i2;\n          }\n        }\n        peek() {\n          const front = this._front;\n          const cursor = this._cursor;\n          return front._elements[cursor];\n        }\n      }\n      function ReadableStreamReaderGenericInitialize(reader, stream) {\n        reader._ownerReadableStream = stream;\n        stream._reader = reader;\n        if (stream._state === \"readable\") {\n          defaultReaderClosedPromiseInitialize(reader);\n        } else if (stream._state === \"closed\") {\n          defaultReaderClosedPromiseInitializeAsResolved(reader);\n        } else {\n          defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n        }\n      }\n      function ReadableStreamReaderGenericCancel(reader, reason) {\n        const stream = reader._ownerReadableStream;\n        return ReadableStreamCancel(stream, reason);\n      }\n      function ReadableStreamReaderGenericRelease(reader) {\n        if (reader._ownerReadableStream._state === \"readable\") {\n          defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n        } else {\n          defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n        }\n        reader._ownerReadableStream._reader = void 0;\n        reader._ownerReadableStream = void 0;\n      }\n      function readerLockException(name) {\n        return new TypeError(\"Cannot \" + name + \" a stream using a released reader\");\n      }\n      function defaultReaderClosedPromiseInitialize(reader) {\n        reader._closedPromise = newPromise((resolve, reject) => {\n          reader._closedPromise_resolve = resolve;\n          reader._closedPromise_reject = reject;\n        });\n      }\n      function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n        defaultReaderClosedPromiseInitialize(reader);\n        defaultReaderClosedPromiseReject(reader, reason);\n      }\n      function defaultReaderClosedPromiseInitializeAsResolved(reader) {\n        defaultReaderClosedPromiseInitialize(reader);\n        defaultReaderClosedPromiseResolve(reader);\n      }\n      function defaultReaderClosedPromiseReject(reader, reason) {\n        if (reader._closedPromise_reject === void 0) {\n          return;\n        }\n        setPromiseIsHandledToTrue(reader._closedPromise);\n        reader._closedPromise_reject(reason);\n        reader._closedPromise_resolve = void 0;\n        reader._closedPromise_reject = void 0;\n      }\n      function defaultReaderClosedPromiseResetToRejected(reader, reason) {\n        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n      }\n      function defaultReaderClosedPromiseResolve(reader) {\n        if (reader._closedPromise_resolve === void 0) {\n          return;\n        }\n        reader._closedPromise_resolve(void 0);\n        reader._closedPromise_resolve = void 0;\n        reader._closedPromise_reject = void 0;\n      }\n      const AbortSteps = SymbolPolyfill(\"[[AbortSteps]]\");\n      const ErrorSteps = SymbolPolyfill(\"[[ErrorSteps]]\");\n      const CancelSteps = SymbolPolyfill(\"[[CancelSteps]]\");\n      const PullSteps = SymbolPolyfill(\"[[PullSteps]]\");\n      const NumberIsFinite = Number.isFinite || function(x2) {\n        return typeof x2 === \"number\" && isFinite(x2);\n      };\n      const MathTrunc = Math.trunc || function(v) {\n        return v < 0 ? Math.ceil(v) : Math.floor(v);\n      };\n      function isDictionary(x2) {\n        return typeof x2 === \"object\" || typeof x2 === \"function\";\n      }\n      function assertDictionary(obj, context) {\n        if (obj !== void 0 && !isDictionary(obj)) {\n          throw new TypeError(`${context} is not an object.`);\n        }\n      }\n      function assertFunction(x2, context) {\n        if (typeof x2 !== \"function\") {\n          throw new TypeError(`${context} is not a function.`);\n        }\n      }\n      function isObject(x2) {\n        return typeof x2 === \"object\" && x2 !== null || typeof x2 === \"function\";\n      }\n      function assertObject(x2, context) {\n        if (!isObject(x2)) {\n          throw new TypeError(`${context} is not an object.`);\n        }\n      }\n      function assertRequiredArgument(x2, position, context) {\n        if (x2 === void 0) {\n          throw new TypeError(`Parameter ${position} is required in '${context}'.`);\n        }\n      }\n      function assertRequiredField(x2, field, context) {\n        if (x2 === void 0) {\n          throw new TypeError(`${field} is required in '${context}'.`);\n        }\n      }\n      function convertUnrestrictedDouble(value) {\n        return Number(value);\n      }\n      function censorNegativeZero(x2) {\n        return x2 === 0 ? 0 : x2;\n      }\n      function integerPart(x2) {\n        return censorNegativeZero(MathTrunc(x2));\n      }\n      function convertUnsignedLongLongWithEnforceRange(value, context) {\n        const lowerBound = 0;\n        const upperBound = Number.MAX_SAFE_INTEGER;\n        let x2 = Number(value);\n        x2 = censorNegativeZero(x2);\n        if (!NumberIsFinite(x2)) {\n          throw new TypeError(`${context} is not a finite number`);\n        }\n        x2 = integerPart(x2);\n        if (x2 < lowerBound || x2 > upperBound) {\n          throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\n        }\n        if (!NumberIsFinite(x2) || x2 === 0) {\n          return 0;\n        }\n        return x2;\n      }\n      function assertReadableStream(x2, context) {\n        if (!IsReadableStream(x2)) {\n          throw new TypeError(`${context} is not a ReadableStream.`);\n        }\n      }\n      function AcquireReadableStreamDefaultReader(stream) {\n        return new ReadableStreamDefaultReader(stream);\n      }\n      function ReadableStreamAddReadRequest(stream, readRequest) {\n        stream._reader._readRequests.push(readRequest);\n      }\n      function ReadableStreamFulfillReadRequest(stream, chunk, done) {\n        const reader = stream._reader;\n        const readRequest = reader._readRequests.shift();\n        if (done) {\n          readRequest._closeSteps();\n        } else {\n          readRequest._chunkSteps(chunk);\n        }\n      }\n      function ReadableStreamGetNumReadRequests(stream) {\n        return stream._reader._readRequests.length;\n      }\n      function ReadableStreamHasDefaultReader(stream) {\n        const reader = stream._reader;\n        if (reader === void 0) {\n          return false;\n        }\n        if (!IsReadableStreamDefaultReader(reader)) {\n          return false;\n        }\n        return true;\n      }\n      class ReadableStreamDefaultReader {\n        constructor(stream) {\n          assertRequiredArgument(stream, 1, \"ReadableStreamDefaultReader\");\n          assertReadableStream(stream, \"First parameter\");\n          if (IsReadableStreamLocked(stream)) {\n            throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n          }\n          ReadableStreamReaderGenericInitialize(this, stream);\n          this._readRequests = new SimpleQueue();\n        }\n        get closed() {\n          if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException(\"closed\"));\n          }\n          return this._closedPromise;\n        }\n        cancel(reason = void 0) {\n          if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException(\"cancel\"));\n          }\n          if (this._ownerReadableStream === void 0) {\n            return promiseRejectedWith(readerLockException(\"cancel\"));\n          }\n          return ReadableStreamReaderGenericCancel(this, reason);\n        }\n        read() {\n          if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException(\"read\"));\n          }\n          if (this._ownerReadableStream === void 0) {\n            return promiseRejectedWith(readerLockException(\"read from\"));\n          }\n          let resolvePromise;\n          let rejectPromise;\n          const promise = newPromise((resolve, reject) => {\n            resolvePromise = resolve;\n            rejectPromise = reject;\n          });\n          const readRequest = {\n            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),\n            _closeSteps: () => resolvePromise({ value: void 0, done: true }),\n            _errorSteps: (e2) => rejectPromise(e2)\n          };\n          ReadableStreamDefaultReaderRead(this, readRequest);\n          return promise;\n        }\n        releaseLock() {\n          if (!IsReadableStreamDefaultReader(this)) {\n            throw defaultReaderBrandCheckException(\"releaseLock\");\n          }\n          if (this._ownerReadableStream === void 0) {\n            return;\n          }\n          if (this._readRequests.length > 0) {\n            throw new TypeError(\"Tried to release a reader lock when that reader has pending read() calls un-settled\");\n          }\n          ReadableStreamReaderGenericRelease(this);\n        }\n      }\n      Object.defineProperties(ReadableStreamDefaultReader.prototype, {\n        cancel: { enumerable: true },\n        read: { enumerable: true },\n        releaseLock: { enumerable: true },\n        closed: { enumerable: true }\n      });\n      if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {\n          value: \"ReadableStreamDefaultReader\",\n          configurable: true\n        });\n      }\n      function IsReadableStreamDefaultReader(x2) {\n        if (!typeIsObject(x2)) {\n          return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x2, \"_readRequests\")) {\n          return false;\n        }\n        return x2 instanceof ReadableStreamDefaultReader;\n      }\n      function ReadableStreamDefaultReaderRead(reader, readRequest) {\n        const stream = reader._ownerReadableStream;\n        stream._disturbed = true;\n        if (stream._state === \"closed\") {\n          readRequest._closeSteps();\n        } else if (stream._state === \"errored\") {\n          readRequest._errorSteps(stream._storedError);\n        } else {\n          stream._readableStreamController[PullSteps](readRequest);\n        }\n      }\n      function defaultReaderBrandCheckException(name) {\n        return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n      }\n      const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {\n      }).prototype);\n      class ReadableStreamAsyncIteratorImpl {\n        constructor(reader, preventCancel) {\n          this._ongoingPromise = void 0;\n          this._isFinished = false;\n          this._reader = reader;\n          this._preventCancel = preventCancel;\n        }\n        next() {\n          const nextSteps = () => this._nextSteps();\n          this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();\n          return this._ongoingPromise;\n        }\n        return(value) {\n          const returnSteps = () => this._returnSteps(value);\n          return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();\n        }\n        _nextSteps() {\n          if (this._isFinished) {\n            return Promise.resolve({ value: void 0, done: true });\n          }\n          const reader = this._reader;\n          if (reader._ownerReadableStream === void 0) {\n            return promiseRejectedWith(readerLockException(\"iterate\"));\n          }\n          let resolvePromise;\n          let rejectPromise;\n          const promise = newPromise((resolve, reject) => {\n            resolvePromise = resolve;\n            rejectPromise = reject;\n          });\n          const readRequest = {\n            _chunkSteps: (chunk) => {\n              this._ongoingPromise = void 0;\n              queueMicrotask(() => resolvePromise({ value: chunk, done: false }));\n            },\n            _closeSteps: () => {\n              this._ongoingPromise = void 0;\n              this._isFinished = true;\n              ReadableStreamReaderGenericRelease(reader);\n              resolvePromise({ value: void 0, done: true });\n            },\n            _errorSteps: (reason) => {\n              this._ongoingPromise = void 0;\n              this._isFinished = true;\n              ReadableStreamReaderGenericRelease(reader);\n              rejectPromise(reason);\n            }\n          };\n          ReadableStreamDefaultReaderRead(reader, readRequest);\n          return promise;\n        }\n        _returnSteps(value) {\n          if (this._isFinished) {\n            return Promise.resolve({ value, done: true });\n          }\n          this._isFinished = true;\n          const reader = this._reader;\n          if (reader._ownerReadableStream === void 0) {\n            return promiseRejectedWith(readerLockException(\"finish iterating\"));\n          }\n          if (!this._preventCancel) {\n            const result = ReadableStreamReaderGenericCancel(reader, value);\n            ReadableStreamReaderGenericRelease(reader);\n            return transformPromiseWith(result, () => ({ value, done: true }));\n          }\n          ReadableStreamReaderGenericRelease(reader);\n          return promiseResolvedWith({ value, done: true });\n        }\n      }\n      const ReadableStreamAsyncIteratorPrototype = {\n        next() {\n          if (!IsReadableStreamAsyncIterator(this)) {\n            return promiseRejectedWith(streamAsyncIteratorBrandCheckException(\"next\"));\n          }\n          return this._asyncIteratorImpl.next();\n        },\n        return(value) {\n          if (!IsReadableStreamAsyncIterator(this)) {\n            return promiseRejectedWith(streamAsyncIteratorBrandCheckException(\"return\"));\n          }\n          return this._asyncIteratorImpl.return(value);\n        }\n      };\n      if (AsyncIteratorPrototype !== void 0) {\n        Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n      }\n      function AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n        const reader = AcquireReadableStreamDefaultReader(stream);\n        const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n        const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n        iterator._asyncIteratorImpl = impl;\n        return iterator;\n      }\n      function IsReadableStreamAsyncIterator(x2) {\n        if (!typeIsObject(x2)) {\n          return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x2, \"_asyncIteratorImpl\")) {\n          return false;\n        }\n        try {\n          return x2._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;\n        } catch (_a) {\n          return false;\n        }\n      }\n      function streamAsyncIteratorBrandCheckException(name) {\n        return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n      }\n      const NumberIsNaN = Number.isNaN || function(x2) {\n        return x2 !== x2;\n      };\n      function CreateArrayFromList(elements) {\n        return elements.slice();\n      }\n      function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {\n        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n      }\n      function TransferArrayBuffer(O) {\n        return O;\n      }\n      function IsDetachedBuffer(O) {\n        return false;\n      }\n      function ArrayBufferSlice(buffer, begin, end) {\n        if (buffer.slice) {\n          return buffer.slice(begin, end);\n        }\n        const length = end - begin;\n        const slice = new ArrayBuffer(length);\n        CopyDataBlockBytes(slice, 0, buffer, begin, length);\n        return slice;\n      }\n      function IsNonNegativeNumber(v) {\n        if (typeof v !== \"number\") {\n          return false;\n        }\n        if (NumberIsNaN(v)) {\n          return false;\n        }\n        if (v < 0) {\n          return false;\n        }\n        return true;\n      }\n      function CloneAsUint8Array(O) {\n        const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);\n        return new Uint8Array(buffer);\n      }\n      function DequeueValue(container) {\n        const pair = container._queue.shift();\n        container._queueTotalSize -= pair.size;\n        if (container._queueTotalSize < 0) {\n          container._queueTotalSize = 0;\n        }\n        return pair.value;\n      }\n      function EnqueueValueWithSize(container, value, size) {\n        if (!IsNonNegativeNumber(size) || size === Infinity) {\n          throw new RangeError(\"Size must be a finite, non-NaN, non-negative number.\");\n        }\n        container._queue.push({ value, size });\n        container._queueTotalSize += size;\n      }\n      function PeekQueueValue(container) {\n        const pair = container._queue.peek();\n        return pair.value;\n      }\n      function ResetQueue(container) {\n        container._queue = new SimpleQueue();\n        container._queueTotalSize = 0;\n      }\n      class ReadableStreamBYOBRequest {\n        constructor() {\n          throw new TypeError(\"Illegal constructor\");\n        }\n        get view() {\n          if (!IsReadableStreamBYOBRequest(this)) {\n            throw byobRequestBrandCheckException(\"view\");\n          }\n          return this._view;\n        }\n        respond(bytesWritten) {\n          if (!IsReadableStreamBYOBRequest(this)) {\n            throw byobRequestBrandCheckException(\"respond\");\n          }\n          assertRequiredArgument(bytesWritten, 1, \"respond\");\n          bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, \"First parameter\");\n          if (this._associatedReadableByteStreamController === void 0) {\n            throw new TypeError(\"This BYOB request has been invalidated\");\n          }\n          if (IsDetachedBuffer(this._view.buffer))\n            ;\n          ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n        }\n        respondWithNewView(view) {\n          if (!IsReadableStreamBYOBRequest(this)) {\n            throw byobRequestBrandCheckException(\"respondWithNewView\");\n          }\n          assertRequiredArgument(view, 1, \"respondWithNewView\");\n          if (!ArrayBuffer.isView(view)) {\n            throw new TypeError(\"You can only respond with array buffer views\");\n          }\n          if (this._associatedReadableByteStreamController === void 0) {\n            throw new TypeError(\"This BYOB request has been invalidated\");\n          }\n          if (IsDetachedBuffer(view.buffer))\n            ;\n          ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n        }\n      }\n      Object.defineProperties(ReadableStreamBYOBRequest.prototype, {\n        respond: { enumerable: true },\n        respondWithNewView: { enumerable: true },\n        view: { enumerable: true }\n      });\n      if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {\n          value: \"ReadableStreamBYOBRequest\",\n          configurable: true\n        });\n      }\n      class ReadableByteStreamController {\n        constructor() {\n          throw new TypeError(\"Illegal constructor\");\n        }\n        get byobRequest() {\n          if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException(\"byobRequest\");\n          }\n          return ReadableByteStreamControllerGetBYOBRequest(this);\n        }\n        get desiredSize() {\n          if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException(\"desiredSize\");\n          }\n          return ReadableByteStreamControllerGetDesiredSize(this);\n        }\n        close() {\n          if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException(\"close\");\n          }\n          if (this._closeRequested) {\n            throw new TypeError(\"The stream has already been closed; do not close it again!\");\n          }\n          const state = this._controlledReadableByteStream._state;\n          if (state !== \"readable\") {\n            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n          }\n          ReadableByteStreamControllerClose(this);\n        }\n        enqueue(chunk) {\n          if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException(\"enqueue\");\n          }\n          assertRequiredArgument(chunk, 1, \"enqueue\");\n          if (!ArrayBuffer.isView(chunk)) {\n            throw new TypeError(\"chunk must be an array buffer view\");\n          }\n          if (chunk.byteLength === 0) {\n            throw new TypeError(\"chunk must have non-zero byteLength\");\n          }\n          if (chunk.buffer.byteLength === 0) {\n            throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n          }\n          if (this._closeRequested) {\n            throw new TypeError(\"stream is closed or draining\");\n          }\n          const state = this._controlledReadableByteStream._state;\n          if (state !== \"readable\") {\n            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n          }\n          ReadableByteStreamControllerEnqueue(this, chunk);\n        }\n        error(e2 = void 0) {\n          if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException(\"error\");\n          }\n          ReadableByteStreamControllerError(this, e2);\n        }\n        [CancelSteps](reason) {\n          ReadableByteStreamControllerClearPendingPullIntos(this);\n          ResetQueue(this);\n          const result = this._cancelAlgorithm(reason);\n          ReadableByteStreamControllerClearAlgorithms(this);\n          return result;\n        }\n        [PullSteps](readRequest) {\n          const stream = this._controlledReadableByteStream;\n          if (this._queueTotalSize > 0) {\n            const entry = this._queue.shift();\n            this._queueTotalSize -= entry.byteLength;\n            ReadableByteStreamControllerHandleQueueDrain(this);\n            const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n            readRequest._chunkSteps(view);\n            return;\n          }\n          const autoAllocateChunkSize = this._autoAllocateChunkSize;\n          if (autoAllocateChunkSize !== void 0) {\n            let buffer;\n            try {\n              buffer = new ArrayBuffer(autoAllocateChunkSize);\n            } catch (bufferE) {\n              readRequest._errorSteps(bufferE);\n              return;\n            }\n            const pullIntoDescriptor = {\n              buffer,\n              bufferByteLength: autoAllocateChunkSize,\n              byteOffset: 0,\n              byteLength: autoAllocateChunkSize,\n              bytesFilled: 0,\n              elementSize: 1,\n              viewConstructor: Uint8Array,\n              readerType: \"default\"\n            };\n            this._pendingPullIntos.push(pullIntoDescriptor);\n          }\n          ReadableStreamAddReadRequest(stream, readRequest);\n          ReadableByteStreamControllerCallPullIfNeeded(this);\n        }\n      }\n      Object.defineProperties(ReadableByteStreamController.prototype, {\n        close: { enumerable: true },\n        enqueue: { enumerable: true },\n        error: { enumerable: true },\n        byobRequest: { enumerable: true },\n        desiredSize: { enumerable: true }\n      });\n      if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {\n          value: \"ReadableByteStreamController\",\n          configurable: true\n        });\n      }\n      function IsReadableByteStreamController(x2) {\n        if (!typeIsObject(x2)) {\n          return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x2, \"_controlledReadableByteStream\")) {\n          return false;\n        }\n        return x2 instanceof ReadableByteStreamController;\n      }\n      function IsReadableStreamBYOBRequest(x2) {\n        if (!typeIsObject(x2)) {\n          return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x2, \"_associatedReadableByteStreamController\")) {\n          return false;\n        }\n        return x2 instanceof ReadableStreamBYOBRequest;\n      }\n      function ReadableByteStreamControllerCallPullIfNeeded(controller) {\n        const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n        if (!shouldPull) {\n          return;\n        }\n        if (controller._pulling) {\n          controller._pullAgain = true;\n          return;\n        }\n        controller._pulling = true;\n        const pullPromise = controller._pullAlgorithm();\n        uponPromise(pullPromise, () => {\n          controller._pulling = false;\n          if (controller._pullAgain) {\n            controller._pullAgain = false;\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\n          }\n        }, (e2) => {\n          ReadableByteStreamControllerError(controller, e2);\n        });\n      }\n      function ReadableByteStreamControllerClearPendingPullIntos(controller) {\n        ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n        controller._pendingPullIntos = new SimpleQueue();\n      }\n      function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n        let done = false;\n        if (stream._state === \"closed\") {\n          done = true;\n        }\n        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n        if (pullIntoDescriptor.readerType === \"default\") {\n          ReadableStreamFulfillReadRequest(stream, filledView, done);\n        } else {\n          ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n        }\n      }\n      function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n        const bytesFilled = pullIntoDescriptor.bytesFilled;\n        const elementSize = pullIntoDescriptor.elementSize;\n        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n      }\n      function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n        controller._queue.push({ buffer, byteOffset, byteLength });\n        controller._queueTotalSize += byteLength;\n      }\n      function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n        const elementSize = pullIntoDescriptor.elementSize;\n        const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n        const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n        const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n        const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n        let totalBytesToCopyRemaining = maxBytesToCopy;\n        let ready = false;\n        if (maxAlignedBytes > currentAlignedBytes) {\n          totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n          ready = true;\n        }\n        const queue = controller._queue;\n        while (totalBytesToCopyRemaining > 0) {\n          const headOfQueue = queue.peek();\n          const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n          const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n          CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n          if (headOfQueue.byteLength === bytesToCopy) {\n            queue.shift();\n          } else {\n            headOfQueue.byteOffset += bytesToCopy;\n            headOfQueue.byteLength -= bytesToCopy;\n          }\n          controller._queueTotalSize -= bytesToCopy;\n          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n          totalBytesToCopyRemaining -= bytesToCopy;\n        }\n        return ready;\n      }\n      function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n        pullIntoDescriptor.bytesFilled += size;\n      }\n      function ReadableByteStreamControllerHandleQueueDrain(controller) {\n        if (controller._queueTotalSize === 0 && controller._closeRequested) {\n          ReadableByteStreamControllerClearAlgorithms(controller);\n          ReadableStreamClose(controller._controlledReadableByteStream);\n        } else {\n          ReadableByteStreamControllerCallPullIfNeeded(controller);\n        }\n      }\n      function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n        if (controller._byobRequest === null) {\n          return;\n        }\n        controller._byobRequest._associatedReadableByteStreamController = void 0;\n        controller._byobRequest._view = null;\n        controller._byobRequest = null;\n      }\n      function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n        while (controller._pendingPullIntos.length > 0) {\n          if (controller._queueTotalSize === 0) {\n            return;\n          }\n          const pullIntoDescriptor = controller._pendingPullIntos.peek();\n          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n            ReadableByteStreamControllerShiftPendingPullInto(controller);\n            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n          }\n        }\n      }\n      function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {\n        const stream = controller._controlledReadableByteStream;\n        let elementSize = 1;\n        if (view.constructor !== DataView) {\n          elementSize = view.constructor.BYTES_PER_ELEMENT;\n        }\n        const ctor = view.constructor;\n        const buffer = TransferArrayBuffer(view.buffer);\n        const pullIntoDescriptor = {\n          buffer,\n          bufferByteLength: buffer.byteLength,\n          byteOffset: view.byteOffset,\n          byteLength: view.byteLength,\n          bytesFilled: 0,\n          elementSize,\n          viewConstructor: ctor,\n          readerType: \"byob\"\n        };\n        if (controller._pendingPullIntos.length > 0) {\n          controller._pendingPullIntos.push(pullIntoDescriptor);\n          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n          return;\n        }\n        if (stream._state === \"closed\") {\n          const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n          readIntoRequest._closeSteps(emptyView);\n          return;\n        }\n        if (controller._queueTotalSize > 0) {\n          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n            const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n            ReadableByteStreamControllerHandleQueueDrain(controller);\n            readIntoRequest._chunkSteps(filledView);\n            return;\n          }\n          if (controller._closeRequested) {\n            const e2 = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n            ReadableByteStreamControllerError(controller, e2);\n            readIntoRequest._errorSteps(e2);\n            return;\n          }\n        }\n        controller._pendingPullIntos.push(pullIntoDescriptor);\n        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      }\n      function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n        const stream = controller._controlledReadableByteStream;\n        if (ReadableStreamHasBYOBReader(stream)) {\n          while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n            const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n          }\n        }\n      }\n      function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n          return;\n        }\n        ReadableByteStreamControllerShiftPendingPullInto(controller);\n        const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n        if (remainderSize > 0) {\n          const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n          const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);\n          ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n        }\n        pullIntoDescriptor.bytesFilled -= remainderSize;\n        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n      }\n      function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n        const firstDescriptor = controller._pendingPullIntos.peek();\n        ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n        const state = controller._controlledReadableByteStream._state;\n        if (state === \"closed\") {\n          ReadableByteStreamControllerRespondInClosedState(controller);\n        } else {\n          ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n        }\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      }\n      function ReadableByteStreamControllerShiftPendingPullInto(controller) {\n        const descriptor = controller._pendingPullIntos.shift();\n        return descriptor;\n      }\n      function ReadableByteStreamControllerShouldCallPull(controller) {\n        const stream = controller._controlledReadableByteStream;\n        if (stream._state !== \"readable\") {\n          return false;\n        }\n        if (controller._closeRequested) {\n          return false;\n        }\n        if (!controller._started) {\n          return false;\n        }\n        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n          return true;\n        }\n        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n          return true;\n        }\n        const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n        if (desiredSize > 0) {\n          return true;\n        }\n        return false;\n      }\n      function ReadableByteStreamControllerClearAlgorithms(controller) {\n        controller._pullAlgorithm = void 0;\n        controller._cancelAlgorithm = void 0;\n      }\n      function ReadableByteStreamControllerClose(controller) {\n        const stream = controller._controlledReadableByteStream;\n        if (controller._closeRequested || stream._state !== \"readable\") {\n          return;\n        }\n        if (controller._queueTotalSize > 0) {\n          controller._closeRequested = true;\n          return;\n        }\n        if (controller._pendingPullIntos.length > 0) {\n          const firstPendingPullInto = controller._pendingPullIntos.peek();\n          if (firstPendingPullInto.bytesFilled > 0) {\n            const e2 = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n            ReadableByteStreamControllerError(controller, e2);\n            throw e2;\n          }\n        }\n        ReadableByteStreamControllerClearAlgorithms(controller);\n        ReadableStreamClose(stream);\n      }\n      function ReadableByteStreamControllerEnqueue(controller, chunk) {\n        const stream = controller._controlledReadableByteStream;\n        if (controller._closeRequested || stream._state !== \"readable\") {\n          return;\n        }\n        const buffer = chunk.buffer;\n        const byteOffset = chunk.byteOffset;\n        const byteLength = chunk.byteLength;\n        const transferredBuffer = TransferArrayBuffer(buffer);\n        if (controller._pendingPullIntos.length > 0) {\n          const firstPendingPullInto = controller._pendingPullIntos.peek();\n          if (IsDetachedBuffer(firstPendingPullInto.buffer))\n            ;\n          firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n        }\n        ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n        if (ReadableStreamHasDefaultReader(stream)) {\n          if (ReadableStreamGetNumReadRequests(stream) === 0) {\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n          } else {\n            if (controller._pendingPullIntos.length > 0) {\n              ReadableByteStreamControllerShiftPendingPullInto(controller);\n            }\n            const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n            ReadableStreamFulfillReadRequest(stream, transferredView, false);\n          }\n        } else if (ReadableStreamHasBYOBReader(stream)) {\n          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n        } else {\n          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n        }\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      }\n      function ReadableByteStreamControllerError(controller, e2) {\n        const stream = controller._controlledReadableByteStream;\n        if (stream._state !== \"readable\") {\n          return;\n        }\n        ReadableByteStreamControllerClearPendingPullIntos(controller);\n        ResetQueue(controller);\n        ReadableByteStreamControllerClearAlgorithms(controller);\n        ReadableStreamError(stream, e2);\n      }\n      function ReadableByteStreamControllerGetBYOBRequest(controller) {\n        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {\n          const firstDescriptor = controller._pendingPullIntos.peek();\n          const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n          const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n          SetUpReadableStreamBYOBRequest(byobRequest, controller, view);\n          controller._byobRequest = byobRequest;\n        }\n        return controller._byobRequest;\n      }\n      function ReadableByteStreamControllerGetDesiredSize(controller) {\n        const state = controller._controlledReadableByteStream._state;\n        if (state === \"errored\") {\n          return null;\n        }\n        if (state === \"closed\") {\n          return 0;\n        }\n        return controller._strategyHWM - controller._queueTotalSize;\n      }\n      function ReadableByteStreamControllerRespond(controller, bytesWritten) {\n        const firstDescriptor = controller._pendingPullIntos.peek();\n        const state = controller._controlledReadableByteStream._state;\n        if (state === \"closed\") {\n          if (bytesWritten !== 0) {\n            throw new TypeError(\"bytesWritten must be 0 when calling respond() on a closed stream\");\n          }\n        } else {\n          if (bytesWritten === 0) {\n            throw new TypeError(\"bytesWritten must be greater than 0 when calling respond() on a readable stream\");\n          }\n          if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n            throw new RangeError(\"bytesWritten out of range\");\n          }\n        }\n        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n      }\n      function ReadableByteStreamControllerRespondWithNewView(controller, view) {\n        const firstDescriptor = controller._pendingPullIntos.peek();\n        const state = controller._controlledReadableByteStream._state;\n        if (state === \"closed\") {\n          if (view.byteLength !== 0) {\n            throw new TypeError(\"The view's length must be 0 when calling respondWithNewView() on a closed stream\");\n          }\n        } else {\n          if (view.byteLength === 0) {\n            throw new TypeError(\"The view's length must be greater than 0 when calling respondWithNewView() on a readable stream\");\n          }\n        }\n        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n          throw new RangeError(\"The region specified by view does not match byobRequest\");\n        }\n        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {\n          throw new RangeError(\"The buffer of view has different capacity than byobRequest\");\n        }\n        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {\n          throw new RangeError(\"The region specified by view is larger than byobRequest\");\n        }\n        const viewByteLength = view.byteLength;\n        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);\n        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);\n      }\n      function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n        controller._controlledReadableByteStream = stream;\n        controller._pullAgain = false;\n        controller._pulling = false;\n        controller._byobRequest = null;\n        controller._queue = controller._queueTotalSize = void 0;\n        ResetQueue(controller);\n        controller._closeRequested = false;\n        controller._started = false;\n        controller._strategyHWM = highWaterMark;\n        controller._pullAlgorithm = pullAlgorithm;\n        controller._cancelAlgorithm = cancelAlgorithm;\n        controller._autoAllocateChunkSize = autoAllocateChunkSize;\n        controller._pendingPullIntos = new SimpleQueue();\n        stream._readableStreamController = controller;\n        const startResult = startAlgorithm();\n        uponPromise(promiseResolvedWith(startResult), () => {\n          controller._started = true;\n          ReadableByteStreamControllerCallPullIfNeeded(controller);\n        }, (r2) => {\n          ReadableByteStreamControllerError(controller, r2);\n        });\n      }\n      function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n        const controller = Object.create(ReadableByteStreamController.prototype);\n        let startAlgorithm = () => void 0;\n        let pullAlgorithm = () => promiseResolvedWith(void 0);\n        let cancelAlgorithm = () => promiseResolvedWith(void 0);\n        if (underlyingByteSource.start !== void 0) {\n          startAlgorithm = () => underlyingByteSource.start(controller);\n        }\n        if (underlyingByteSource.pull !== void 0) {\n          pullAlgorithm = () => underlyingByteSource.pull(controller);\n        }\n        if (underlyingByteSource.cancel !== void 0) {\n          cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);\n        }\n        const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n        if (autoAllocateChunkSize === 0) {\n          throw new TypeError(\"autoAllocateChunkSize must be greater than 0\");\n        }\n        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n      }\n      function SetUpReadableStreamBYOBRequest(request, controller, view) {\n        request._associatedReadableByteStreamController = controller;\n        request._view = view;\n      }\n      function byobRequestBrandCheckException(name) {\n        return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n      }\n      function byteStreamControllerBrandCheckException(name) {\n        return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n      }\n      function AcquireReadableStreamBYOBReader(stream) {\n        return new ReadableStreamBYOBReader(stream);\n      }\n      function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n        stream._reader._readIntoRequests.push(readIntoRequest);\n      }\n      function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n        const reader = stream._reader;\n        const readIntoRequest = reader._readIntoRequests.shift();\n        if (done) {\n          readIntoRequest._closeSteps(chunk);\n        } else {\n          readIntoRequest._chunkSteps(chunk);\n        }\n      }\n      function ReadableStreamGetNumReadIntoRequests(stream) {\n        return stream._reader._readIntoRequests.length;\n      }\n      function ReadableStreamHasBYOBReader(stream) {\n        const reader = stream._reader;\n        if (reader === void 0) {\n          return false;\n        }\n        if (!IsReadableStreamBYOBReader(reader)) {\n          return false;\n        }\n        return true;\n      }\n      class ReadableStreamBYOBReader {\n        constructor(stream) {\n          assertRequiredArgument(stream, 1, \"ReadableStreamBYOBReader\");\n          assertReadableStream(stream, \"First parameter\");\n          if (IsReadableStreamLocked(stream)) {\n            throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n          }\n          if (!IsReadableByteStreamController(stream._readableStreamController)) {\n            throw new TypeError(\"Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source\");\n          }\n          ReadableStreamReaderGenericInitialize(this, stream);\n          this._readIntoRequests = new SimpleQueue();\n        }\n        get closed() {\n          if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException(\"closed\"));\n          }\n          return this._closedPromise;\n        }\n        cancel(reason = void 0) {\n          if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException(\"cancel\"));\n          }\n          if (this._ownerReadableStream === void 0) {\n            return promiseRejectedWith(readerLockException(\"cancel\"));\n          }\n          return ReadableStreamReaderGenericCancel(this, reason);\n        }\n        read(view) {\n          if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException(\"read\"));\n          }\n          if (!ArrayBuffer.isView(view)) {\n            return promiseRejectedWith(new TypeError(\"view must be an array buffer view\"));\n          }\n          if (view.byteLength === 0) {\n            return promiseRejectedWith(new TypeError(\"view must have non-zero byteLength\"));\n          }\n          if (view.buffer.byteLength === 0) {\n            return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\n          }\n          if (IsDetachedBuffer(view.buffer))\n            ;\n          if (this._ownerReadableStream === void 0) {\n            return promiseRejectedWith(readerLockException(\"read from\"));\n          }\n          let resolvePromise;\n          let rejectPromise;\n          const promise = newPromise((resolve, reject) => {\n            resolvePromise = resolve;\n            rejectPromise = reject;\n          });\n          const readIntoRequest = {\n            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),\n            _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),\n            _errorSteps: (e2) => rejectPromise(e2)\n          };\n          ReadableStreamBYOBReaderRead(this, view, readIntoRequest);\n          return promise;\n        }\n        releaseLock() {\n          if (!IsReadableStreamBYOBReader(this)) {\n            throw byobReaderBrandCheckException(\"releaseLock\");\n          }\n          if (this._ownerReadableStream === void 0) {\n            return;\n          }\n          if (this._readIntoRequests.length > 0) {\n            throw new TypeError(\"Tried to release a reader lock when that reader has pending read() calls un-settled\");\n          }\n          ReadableStreamReaderGenericRelease(this);\n        }\n      }\n      Object.defineProperties(ReadableStreamBYOBReader.prototype, {\n        cancel: { enumerable: true },\n        read: { enumerable: true },\n        releaseLock: { enumerable: true },\n        closed: { enumerable: true }\n      });\n      if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {\n          value: \"ReadableStreamBYOBReader\",\n          configurable: true\n        });\n      }\n      function IsReadableStreamBYOBReader(x2) {\n        if (!typeIsObject(x2)) {\n          return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x2, \"_readIntoRequests\")) {\n          return false;\n        }\n        return x2 instanceof ReadableStreamBYOBReader;\n      }\n      function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {\n        const stream = reader._ownerReadableStream;\n        stream._disturbed = true;\n        if (stream._state === \"errored\") {\n          readIntoRequest._errorSteps(stream._storedError);\n        } else {\n          ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);\n        }\n      }\n      function byobReaderBrandCheckException(name) {\n        return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n      }\n      function ExtractHighWaterMark(strategy, defaultHWM) {\n        const { highWaterMark } = strategy;\n        if (highWaterMark === void 0) {\n          return defaultHWM;\n        }\n        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n          throw new RangeError(\"Invalid highWaterMark\");\n        }\n        return highWaterMark;\n      }\n      function ExtractSizeAlgorithm(strategy) {\n        const { size } = strategy;\n        if (!size) {\n          return () => 1;\n        }\n        return size;\n      }\n      function convertQueuingStrategy(init, context) {\n        assertDictionary(init, context);\n        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n        const size = init === null || init === void 0 ? void 0 : init.size;\n        return {\n          highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),\n          size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)\n        };\n      }\n      function convertQueuingStrategySize(fn, context) {\n        assertFunction(fn, context);\n        return (chunk) => convertUnrestrictedDouble(fn(chunk));\n      }\n      function convertUnderlyingSink(original, context) {\n        assertDictionary(original, context);\n        const abort = original === null || original === void 0 ? void 0 : original.abort;\n        const close = original === null || original === void 0 ? void 0 : original.close;\n        const start = original === null || original === void 0 ? void 0 : original.start;\n        const type = original === null || original === void 0 ? void 0 : original.type;\n        const write = original === null || original === void 0 ? void 0 : original.write;\n        return {\n          abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),\n          close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),\n          start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),\n          write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),\n          type\n        };\n      }\n      function convertUnderlyingSinkAbortCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (reason) => promiseCall(fn, original, [reason]);\n      }\n      function convertUnderlyingSinkCloseCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return () => promiseCall(fn, original, []);\n      }\n      function convertUnderlyingSinkStartCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller) => reflectCall(fn, original, [controller]);\n      }\n      function convertUnderlyingSinkWriteCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);\n      }\n      function assertWritableStream(x2, context) {\n        if (!IsWritableStream(x2)) {\n          throw new TypeError(`${context} is not a WritableStream.`);\n        }\n      }\n      function isAbortSignal2(value) {\n        if (typeof value !== \"object\" || value === null) {\n          return false;\n        }\n        try {\n          return typeof value.aborted === \"boolean\";\n        } catch (_a) {\n          return false;\n        }\n      }\n      const supportsAbortController = typeof AbortController === \"function\";\n      function createAbortController() {\n        if (supportsAbortController) {\n          return new AbortController();\n        }\n        return void 0;\n      }\n      class WritableStream {\n        constructor(rawUnderlyingSink = {}, rawStrategy = {}) {\n          if (rawUnderlyingSink === void 0) {\n            rawUnderlyingSink = null;\n          } else {\n            assertObject(rawUnderlyingSink, \"First parameter\");\n          }\n          const strategy = convertQueuingStrategy(rawStrategy, \"Second parameter\");\n          const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, \"First parameter\");\n          InitializeWritableStream(this);\n          const type = underlyingSink.type;\n          if (type !== void 0) {\n            throw new RangeError(\"Invalid type is specified\");\n          }\n          const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n          const highWaterMark = ExtractHighWaterMark(strategy, 1);\n          SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n        }\n        get locked() {\n          if (!IsWritableStream(this)) {\n            throw streamBrandCheckException$2(\"locked\");\n          }\n          return IsWritableStreamLocked(this);\n        }\n        abort(reason = void 0) {\n          if (!IsWritableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$2(\"abort\"));\n          }\n          if (IsWritableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError(\"Cannot abort a stream that already has a writer\"));\n          }\n          return WritableStreamAbort(this, reason);\n        }\n        close() {\n          if (!IsWritableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$2(\"close\"));\n          }\n          if (IsWritableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError(\"Cannot close a stream that already has a writer\"));\n          }\n          if (WritableStreamCloseQueuedOrInFlight(this)) {\n            return promiseRejectedWith(new TypeError(\"Cannot close an already-closing stream\"));\n          }\n          return WritableStreamClose(this);\n        }\n        getWriter() {\n          if (!IsWritableStream(this)) {\n            throw streamBrandCheckException$2(\"getWriter\");\n          }\n          return AcquireWritableStreamDefaultWriter(this);\n        }\n      }\n      Object.defineProperties(WritableStream.prototype, {\n        abort: { enumerable: true },\n        close: { enumerable: true },\n        getWriter: { enumerable: true },\n        locked: { enumerable: true }\n      });\n      if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {\n          value: \"WritableStream\",\n          configurable: true\n        });\n      }\n      function AcquireWritableStreamDefaultWriter(stream) {\n        return new WritableStreamDefaultWriter(stream);\n      }\n      function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n        const stream = Object.create(WritableStream.prototype);\n        InitializeWritableStream(stream);\n        const controller = Object.create(WritableStreamDefaultController.prototype);\n        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n        return stream;\n      }\n      function InitializeWritableStream(stream) {\n        stream._state = \"writable\";\n        stream._storedError = void 0;\n        stream._writer = void 0;\n        stream._writableStreamController = void 0;\n        stream._writeRequests = new SimpleQueue();\n        stream._inFlightWriteRequest = void 0;\n        stream._closeRequest = void 0;\n        stream._inFlightCloseRequest = void 0;\n        stream._pendingAbortRequest = void 0;\n        stream._backpressure = false;\n      }\n      function IsWritableStream(x2) {\n        if (!typeIsObject(x2)) {\n          return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x2, \"_writableStreamController\")) {\n          return false;\n        }\n        return x2 instanceof WritableStream;\n      }\n      function IsWritableStreamLocked(stream) {\n        if (stream._writer === void 0) {\n          return false;\n        }\n        return true;\n      }\n      function WritableStreamAbort(stream, reason) {\n        var _a;\n        if (stream._state === \"closed\" || stream._state === \"errored\") {\n          return promiseResolvedWith(void 0);\n        }\n        stream._writableStreamController._abortReason = reason;\n        (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();\n        const state = stream._state;\n        if (state === \"closed\" || state === \"errored\") {\n          return promiseResolvedWith(void 0);\n        }\n        if (stream._pendingAbortRequest !== void 0) {\n          return stream._pendingAbortRequest._promise;\n        }\n        let wasAlreadyErroring = false;\n        if (state === \"erroring\") {\n          wasAlreadyErroring = true;\n          reason = void 0;\n        }\n        const promise = newPromise((resolve, reject) => {\n          stream._pendingAbortRequest = {\n            _promise: void 0,\n            _resolve: resolve,\n            _reject: reject,\n            _reason: reason,\n            _wasAlreadyErroring: wasAlreadyErroring\n          };\n        });\n        stream._pendingAbortRequest._promise = promise;\n        if (!wasAlreadyErroring) {\n          WritableStreamStartErroring(stream, reason);\n        }\n        return promise;\n      }\n      function WritableStreamClose(stream) {\n        const state = stream._state;\n        if (state === \"closed\" || state === \"errored\") {\n          return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));\n        }\n        const promise = newPromise((resolve, reject) => {\n          const closeRequest = {\n            _resolve: resolve,\n            _reject: reject\n          };\n          stream._closeRequest = closeRequest;\n        });\n        const writer = stream._writer;\n        if (writer !== void 0 && stream._backpressure && state === \"writable\") {\n          defaultWriterReadyPromiseResolve(writer);\n        }\n        WritableStreamDefaultControllerClose(stream._writableStreamController);\n        return promise;\n      }\n      function WritableStreamAddWriteRequest(stream) {\n        const promise = newPromise((resolve, reject) => {\n          const writeRequest = {\n            _resolve: resolve,\n            _reject: reject\n          };\n          stream._writeRequests.push(writeRequest);\n        });\n        return promise;\n      }\n      function WritableStreamDealWithRejection(stream, error) {\n        const state = stream._state;\n        if (state === \"writable\") {\n          WritableStreamStartErroring(stream, error);\n          return;\n        }\n        WritableStreamFinishErroring(stream);\n      }\n      function WritableStreamStartErroring(stream, reason) {\n        const controller = stream._writableStreamController;\n        stream._state = \"erroring\";\n        stream._storedError = reason;\n        const writer = stream._writer;\n        if (writer !== void 0) {\n          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n        }\n        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n          WritableStreamFinishErroring(stream);\n        }\n      }\n      function WritableStreamFinishErroring(stream) {\n        stream._state = \"errored\";\n        stream._writableStreamController[ErrorSteps]();\n        const storedError = stream._storedError;\n        stream._writeRequests.forEach((writeRequest) => {\n          writeRequest._reject(storedError);\n        });\n        stream._writeRequests = new SimpleQueue();\n        if (stream._pendingAbortRequest === void 0) {\n          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n          return;\n        }\n        const abortRequest = stream._pendingAbortRequest;\n        stream._pendingAbortRequest = void 0;\n        if (abortRequest._wasAlreadyErroring) {\n          abortRequest._reject(storedError);\n          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n          return;\n        }\n        const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n        uponPromise(promise, () => {\n          abortRequest._resolve();\n          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        }, (reason) => {\n          abortRequest._reject(reason);\n          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        });\n      }\n      function WritableStreamFinishInFlightWrite(stream) {\n        stream._inFlightWriteRequest._resolve(void 0);\n        stream._inFlightWriteRequest = void 0;\n      }\n      function WritableStreamFinishInFlightWriteWithError(stream, error) {\n        stream._inFlightWriteRequest._reject(error);\n        stream._inFlightWriteRequest = void 0;\n        WritableStreamDealWithRejection(stream, error);\n      }\n      function WritableStreamFinishInFlightClose(stream) {\n        stream._inFlightCloseRequest._resolve(void 0);\n        stream._inFlightCloseRequest = void 0;\n        const state = stream._state;\n        if (state === \"erroring\") {\n          stream._storedError = void 0;\n          if (stream._pendingAbortRequest !== void 0) {\n            stream._pendingAbortRequest._resolve();\n            stream._pendingAbortRequest = void 0;\n          }\n        }\n        stream._state = \"closed\";\n        const writer = stream._writer;\n        if (writer !== void 0) {\n          defaultWriterClosedPromiseResolve(writer);\n        }\n      }\n      function WritableStreamFinishInFlightCloseWithError(stream, error) {\n        stream._inFlightCloseRequest._reject(error);\n        stream._inFlightCloseRequest = void 0;\n        if (stream._pendingAbortRequest !== void 0) {\n          stream._pendingAbortRequest._reject(error);\n          stream._pendingAbortRequest = void 0;\n        }\n        WritableStreamDealWithRejection(stream, error);\n      }\n      function WritableStreamCloseQueuedOrInFlight(stream) {\n        if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {\n          return false;\n        }\n        return true;\n      }\n      function WritableStreamHasOperationMarkedInFlight(stream) {\n        if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {\n          return false;\n        }\n        return true;\n      }\n      function WritableStreamMarkCloseRequestInFlight(stream) {\n        stream._inFlightCloseRequest = stream._closeRequest;\n        stream._closeRequest = void 0;\n      }\n      function WritableStreamMarkFirstWriteRequestInFlight(stream) {\n        stream._inFlightWriteRequest = stream._writeRequests.shift();\n      }\n      function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n        if (stream._closeRequest !== void 0) {\n          stream._closeRequest._reject(stream._storedError);\n          stream._closeRequest = void 0;\n        }\n        const writer = stream._writer;\n        if (writer !== void 0) {\n          defaultWriterClosedPromiseReject(writer, stream._storedError);\n        }\n      }\n      function WritableStreamUpdateBackpressure(stream, backpressure) {\n        const writer = stream._writer;\n        if (writer !== void 0 && backpressure !== stream._backpressure) {\n          if (backpressure) {\n            defaultWriterReadyPromiseReset(writer);\n          } else {\n            defaultWriterReadyPromiseResolve(writer);\n          }\n        }\n        stream._backpressure = backpressure;\n      }\n      class WritableStreamDefaultWriter {\n        constructor(stream) {\n          assertRequiredArgument(stream, 1, \"WritableStreamDefaultWriter\");\n          assertWritableStream(stream, \"First parameter\");\n          if (IsWritableStreamLocked(stream)) {\n            throw new TypeError(\"This stream has already been locked for exclusive writing by another writer\");\n          }\n          this._ownerWritableStream = stream;\n          stream._writer = this;\n          const state = stream._state;\n          if (state === \"writable\") {\n            if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n              defaultWriterReadyPromiseInitialize(this);\n            } else {\n              defaultWriterReadyPromiseInitializeAsResolved(this);\n            }\n            defaultWriterClosedPromiseInitialize(this);\n          } else if (state === \"erroring\") {\n            defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n            defaultWriterClosedPromiseInitialize(this);\n          } else if (state === \"closed\") {\n            defaultWriterReadyPromiseInitializeAsResolved(this);\n            defaultWriterClosedPromiseInitializeAsResolved(this);\n          } else {\n            const storedError = stream._storedError;\n            defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n            defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n          }\n        }\n        get closed() {\n          if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException(\"closed\"));\n          }\n          return this._closedPromise;\n        }\n        get desiredSize() {\n          if (!IsWritableStreamDefaultWriter(this)) {\n            throw defaultWriterBrandCheckException(\"desiredSize\");\n          }\n          if (this._ownerWritableStream === void 0) {\n            throw defaultWriterLockException(\"desiredSize\");\n          }\n          return WritableStreamDefaultWriterGetDesiredSize(this);\n        }\n        get ready() {\n          if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException(\"ready\"));\n          }\n          return this._readyPromise;\n        }\n        abort(reason = void 0) {\n          if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException(\"abort\"));\n          }\n          if (this._ownerWritableStream === void 0) {\n            return promiseRejectedWith(defaultWriterLockException(\"abort\"));\n          }\n          return WritableStreamDefaultWriterAbort(this, reason);\n        }\n        close() {\n          if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException(\"close\"));\n          }\n          const stream = this._ownerWritableStream;\n          if (stream === void 0) {\n            return promiseRejectedWith(defaultWriterLockException(\"close\"));\n          }\n          if (WritableStreamCloseQueuedOrInFlight(stream)) {\n            return promiseRejectedWith(new TypeError(\"Cannot close an already-closing stream\"));\n          }\n          return WritableStreamDefaultWriterClose(this);\n        }\n        releaseLock() {\n          if (!IsWritableStreamDefaultWriter(this)) {\n            throw defaultWriterBrandCheckException(\"releaseLock\");\n          }\n          const stream = this._ownerWritableStream;\n          if (stream === void 0) {\n            return;\n          }\n          WritableStreamDefaultWriterRelease(this);\n        }\n        write(chunk = void 0) {\n          if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException(\"write\"));\n          }\n          if (this._ownerWritableStream === void 0) {\n            return promiseRejectedWith(defaultWriterLockException(\"write to\"));\n          }\n          return WritableStreamDefaultWriterWrite(this, chunk);\n        }\n      }\n      Object.defineProperties(WritableStreamDefaultWriter.prototype, {\n        abort: { enumerable: true },\n        close: { enumerable: true },\n        releaseLock: { enumerable: true },\n        write: { enumerable: true },\n        closed: { enumerable: true },\n        desiredSize: { enumerable: true },\n        ready: { enumerable: true }\n      });\n      if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {\n          value: \"WritableStreamDefaultWriter\",\n          configurable: true\n        });\n      }\n      function IsWritableStreamDefaultWriter(x2) {\n        if (!typeIsObject(x2)) {\n          return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x2, \"_ownerWritableStream\")) {\n          return false;\n        }\n        return x2 instanceof WritableStreamDefaultWriter;\n      }\n      function WritableStreamDefaultWriterAbort(writer, reason) {\n        const stream = writer._ownerWritableStream;\n        return WritableStreamAbort(stream, reason);\n      }\n      function WritableStreamDefaultWriterClose(writer) {\n        const stream = writer._ownerWritableStream;\n        return WritableStreamClose(stream);\n      }\n      function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n        const stream = writer._ownerWritableStream;\n        const state = stream._state;\n        if (WritableStreamCloseQueuedOrInFlight(stream) || state === \"closed\") {\n          return promiseResolvedWith(void 0);\n        }\n        if (state === \"errored\") {\n          return promiseRejectedWith(stream._storedError);\n        }\n        return WritableStreamDefaultWriterClose(writer);\n      }\n      function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n        if (writer._closedPromiseState === \"pending\") {\n          defaultWriterClosedPromiseReject(writer, error);\n        } else {\n          defaultWriterClosedPromiseResetToRejected(writer, error);\n        }\n      }\n      function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n        if (writer._readyPromiseState === \"pending\") {\n          defaultWriterReadyPromiseReject(writer, error);\n        } else {\n          defaultWriterReadyPromiseResetToRejected(writer, error);\n        }\n      }\n      function WritableStreamDefaultWriterGetDesiredSize(writer) {\n        const stream = writer._ownerWritableStream;\n        const state = stream._state;\n        if (state === \"errored\" || state === \"erroring\") {\n          return null;\n        }\n        if (state === \"closed\") {\n          return 0;\n        }\n        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n      }\n      function WritableStreamDefaultWriterRelease(writer) {\n        const stream = writer._ownerWritableStream;\n        const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n        stream._writer = void 0;\n        writer._ownerWritableStream = void 0;\n      }\n      function WritableStreamDefaultWriterWrite(writer, chunk) {\n        const stream = writer._ownerWritableStream;\n        const controller = stream._writableStreamController;\n        const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n        if (stream !== writer._ownerWritableStream) {\n          return promiseRejectedWith(defaultWriterLockException(\"write to\"));\n        }\n        const state = stream._state;\n        if (state === \"errored\") {\n          return promiseRejectedWith(stream._storedError);\n        }\n        if (WritableStreamCloseQueuedOrInFlight(stream) || state === \"closed\") {\n          return promiseRejectedWith(new TypeError(\"The stream is closing or closed and cannot be written to\"));\n        }\n        if (state === \"erroring\") {\n          return promiseRejectedWith(stream._storedError);\n        }\n        const promise = WritableStreamAddWriteRequest(stream);\n        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n        return promise;\n      }\n      const closeSentinel = {};\n      class WritableStreamDefaultController {\n        constructor() {\n          throw new TypeError(\"Illegal constructor\");\n        }\n        get abortReason() {\n          if (!IsWritableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$2(\"abortReason\");\n          }\n          return this._abortReason;\n        }\n        get signal() {\n          if (!IsWritableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$2(\"signal\");\n          }\n          if (this._abortController === void 0) {\n            throw new TypeError(\"WritableStreamDefaultController.prototype.signal is not supported\");\n          }\n          return this._abortController.signal;\n        }\n        error(e2 = void 0) {\n          if (!IsWritableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$2(\"error\");\n          }\n          const state = this._controlledWritableStream._state;\n          if (state !== \"writable\") {\n            return;\n          }\n          WritableStreamDefaultControllerError(this, e2);\n        }\n        [AbortSteps](reason) {\n          const result = this._abortAlgorithm(reason);\n          WritableStreamDefaultControllerClearAlgorithms(this);\n          return result;\n        }\n        [ErrorSteps]() {\n          ResetQueue(this);\n        }\n      }\n      Object.defineProperties(WritableStreamDefaultController.prototype, {\n        abortReason: { enumerable: true },\n        signal: { enumerable: true },\n        error: { enumerable: true }\n      });\n      if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n          value: \"WritableStreamDefaultController\",\n          configurable: true\n        });\n      }\n      function IsWritableStreamDefaultController(x2) {\n        if (!typeIsObject(x2)) {\n          return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x2, \"_controlledWritableStream\")) {\n          return false;\n        }\n        return x2 instanceof WritableStreamDefaultController;\n      }\n      function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n        controller._controlledWritableStream = stream;\n        stream._writableStreamController = controller;\n        controller._queue = void 0;\n        controller._queueTotalSize = void 0;\n        ResetQueue(controller);\n        controller._abortReason = void 0;\n        controller._abortController = createAbortController();\n        controller._started = false;\n        controller._strategySizeAlgorithm = sizeAlgorithm;\n        controller._strategyHWM = highWaterMark;\n        controller._writeAlgorithm = writeAlgorithm;\n        controller._closeAlgorithm = closeAlgorithm;\n        controller._abortAlgorithm = abortAlgorithm;\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n        const startResult = startAlgorithm();\n        const startPromise = promiseResolvedWith(startResult);\n        uponPromise(startPromise, () => {\n          controller._started = true;\n          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n        }, (r2) => {\n          controller._started = true;\n          WritableStreamDealWithRejection(stream, r2);\n        });\n      }\n      function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n        const controller = Object.create(WritableStreamDefaultController.prototype);\n        let startAlgorithm = () => void 0;\n        let writeAlgorithm = () => promiseResolvedWith(void 0);\n        let closeAlgorithm = () => promiseResolvedWith(void 0);\n        let abortAlgorithm = () => promiseResolvedWith(void 0);\n        if (underlyingSink.start !== void 0) {\n          startAlgorithm = () => underlyingSink.start(controller);\n        }\n        if (underlyingSink.write !== void 0) {\n          writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);\n        }\n        if (underlyingSink.close !== void 0) {\n          closeAlgorithm = () => underlyingSink.close();\n        }\n        if (underlyingSink.abort !== void 0) {\n          abortAlgorithm = (reason) => underlyingSink.abort(reason);\n        }\n        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n      }\n      function WritableStreamDefaultControllerClearAlgorithms(controller) {\n        controller._writeAlgorithm = void 0;\n        controller._closeAlgorithm = void 0;\n        controller._abortAlgorithm = void 0;\n        controller._strategySizeAlgorithm = void 0;\n      }\n      function WritableStreamDefaultControllerClose(controller) {\n        EnqueueValueWithSize(controller, closeSentinel, 0);\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n      }\n      function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n        try {\n          return controller._strategySizeAlgorithm(chunk);\n        } catch (chunkSizeE) {\n          WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n          return 1;\n        }\n      }\n      function WritableStreamDefaultControllerGetDesiredSize(controller) {\n        return controller._strategyHWM - controller._queueTotalSize;\n      }\n      function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n        try {\n          EnqueueValueWithSize(controller, chunk, chunkSize);\n        } catch (enqueueE) {\n          WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n          return;\n        }\n        const stream = controller._controlledWritableStream;\n        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === \"writable\") {\n          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n          WritableStreamUpdateBackpressure(stream, backpressure);\n        }\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n      }\n      function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n        const stream = controller._controlledWritableStream;\n        if (!controller._started) {\n          return;\n        }\n        if (stream._inFlightWriteRequest !== void 0) {\n          return;\n        }\n        const state = stream._state;\n        if (state === \"erroring\") {\n          WritableStreamFinishErroring(stream);\n          return;\n        }\n        if (controller._queue.length === 0) {\n          return;\n        }\n        const value = PeekQueueValue(controller);\n        if (value === closeSentinel) {\n          WritableStreamDefaultControllerProcessClose(controller);\n        } else {\n          WritableStreamDefaultControllerProcessWrite(controller, value);\n        }\n      }\n      function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n        if (controller._controlledWritableStream._state === \"writable\") {\n          WritableStreamDefaultControllerError(controller, error);\n        }\n      }\n      function WritableStreamDefaultControllerProcessClose(controller) {\n        const stream = controller._controlledWritableStream;\n        WritableStreamMarkCloseRequestInFlight(stream);\n        DequeueValue(controller);\n        const sinkClosePromise = controller._closeAlgorithm();\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n        uponPromise(sinkClosePromise, () => {\n          WritableStreamFinishInFlightClose(stream);\n        }, (reason) => {\n          WritableStreamFinishInFlightCloseWithError(stream, reason);\n        });\n      }\n      function WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n        const stream = controller._controlledWritableStream;\n        WritableStreamMarkFirstWriteRequestInFlight(stream);\n        const sinkWritePromise = controller._writeAlgorithm(chunk);\n        uponPromise(sinkWritePromise, () => {\n          WritableStreamFinishInFlightWrite(stream);\n          const state = stream._state;\n          DequeueValue(controller);\n          if (!WritableStreamCloseQueuedOrInFlight(stream) && state === \"writable\") {\n            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n            WritableStreamUpdateBackpressure(stream, backpressure);\n          }\n          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n        }, (reason) => {\n          if (stream._state === \"writable\") {\n            WritableStreamDefaultControllerClearAlgorithms(controller);\n          }\n          WritableStreamFinishInFlightWriteWithError(stream, reason);\n        });\n      }\n      function WritableStreamDefaultControllerGetBackpressure(controller) {\n        const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n        return desiredSize <= 0;\n      }\n      function WritableStreamDefaultControllerError(controller, error) {\n        const stream = controller._controlledWritableStream;\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n        WritableStreamStartErroring(stream, error);\n      }\n      function streamBrandCheckException$2(name) {\n        return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n      }\n      function defaultControllerBrandCheckException$2(name) {\n        return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);\n      }\n      function defaultWriterBrandCheckException(name) {\n        return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n      }\n      function defaultWriterLockException(name) {\n        return new TypeError(\"Cannot \" + name + \" a stream using a released writer\");\n      }\n      function defaultWriterClosedPromiseInitialize(writer) {\n        writer._closedPromise = newPromise((resolve, reject) => {\n          writer._closedPromise_resolve = resolve;\n          writer._closedPromise_reject = reject;\n          writer._closedPromiseState = \"pending\";\n        });\n      }\n      function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n        defaultWriterClosedPromiseInitialize(writer);\n        defaultWriterClosedPromiseReject(writer, reason);\n      }\n      function defaultWriterClosedPromiseInitializeAsResolved(writer) {\n        defaultWriterClosedPromiseInitialize(writer);\n        defaultWriterClosedPromiseResolve(writer);\n      }\n      function defaultWriterClosedPromiseReject(writer, reason) {\n        if (writer._closedPromise_reject === void 0) {\n          return;\n        }\n        setPromiseIsHandledToTrue(writer._closedPromise);\n        writer._closedPromise_reject(reason);\n        writer._closedPromise_resolve = void 0;\n        writer._closedPromise_reject = void 0;\n        writer._closedPromiseState = \"rejected\";\n      }\n      function defaultWriterClosedPromiseResetToRejected(writer, reason) {\n        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n      }\n      function defaultWriterClosedPromiseResolve(writer) {\n        if (writer._closedPromise_resolve === void 0) {\n          return;\n        }\n        writer._closedPromise_resolve(void 0);\n        writer._closedPromise_resolve = void 0;\n        writer._closedPromise_reject = void 0;\n        writer._closedPromiseState = \"resolved\";\n      }\n      function defaultWriterReadyPromiseInitialize(writer) {\n        writer._readyPromise = newPromise((resolve, reject) => {\n          writer._readyPromise_resolve = resolve;\n          writer._readyPromise_reject = reject;\n        });\n        writer._readyPromiseState = \"pending\";\n      }\n      function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n        defaultWriterReadyPromiseInitialize(writer);\n        defaultWriterReadyPromiseReject(writer, reason);\n      }\n      function defaultWriterReadyPromiseInitializeAsResolved(writer) {\n        defaultWriterReadyPromiseInitialize(writer);\n        defaultWriterReadyPromiseResolve(writer);\n      }\n      function defaultWriterReadyPromiseReject(writer, reason) {\n        if (writer._readyPromise_reject === void 0) {\n          return;\n        }\n        setPromiseIsHandledToTrue(writer._readyPromise);\n        writer._readyPromise_reject(reason);\n        writer._readyPromise_resolve = void 0;\n        writer._readyPromise_reject = void 0;\n        writer._readyPromiseState = \"rejected\";\n      }\n      function defaultWriterReadyPromiseReset(writer) {\n        defaultWriterReadyPromiseInitialize(writer);\n      }\n      function defaultWriterReadyPromiseResetToRejected(writer, reason) {\n        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n      }\n      function defaultWriterReadyPromiseResolve(writer) {\n        if (writer._readyPromise_resolve === void 0) {\n          return;\n        }\n        writer._readyPromise_resolve(void 0);\n        writer._readyPromise_resolve = void 0;\n        writer._readyPromise_reject = void 0;\n        writer._readyPromiseState = \"fulfilled\";\n      }\n      const NativeDOMException = typeof DOMException !== \"undefined\" ? DOMException : void 0;\n      function isDOMExceptionConstructor(ctor) {\n        if (!(typeof ctor === \"function\" || typeof ctor === \"object\")) {\n          return false;\n        }\n        try {\n          new ctor();\n          return true;\n        } catch (_a) {\n          return false;\n        }\n      }\n      function createDOMExceptionPolyfill() {\n        const ctor = function DOMException3(message, name) {\n          this.message = message || \"\";\n          this.name = name || \"Error\";\n          if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n          }\n        };\n        ctor.prototype = Object.create(Error.prototype);\n        Object.defineProperty(ctor.prototype, \"constructor\", { value: ctor, writable: true, configurable: true });\n        return ctor;\n      }\n      const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();\n      function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n        const reader = AcquireReadableStreamDefaultReader(source);\n        const writer = AcquireWritableStreamDefaultWriter(dest);\n        source._disturbed = true;\n        let shuttingDown = false;\n        let currentWrite = promiseResolvedWith(void 0);\n        return newPromise((resolve, reject) => {\n          let abortAlgorithm;\n          if (signal !== void 0) {\n            abortAlgorithm = () => {\n              const error = new DOMException$1(\"Aborted\", \"AbortError\");\n              const actions = [];\n              if (!preventAbort) {\n                actions.push(() => {\n                  if (dest._state === \"writable\") {\n                    return WritableStreamAbort(dest, error);\n                  }\n                  return promiseResolvedWith(void 0);\n                });\n              }\n              if (!preventCancel) {\n                actions.push(() => {\n                  if (source._state === \"readable\") {\n                    return ReadableStreamCancel(source, error);\n                  }\n                  return promiseResolvedWith(void 0);\n                });\n              }\n              shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error);\n            };\n            if (signal.aborted) {\n              abortAlgorithm();\n              return;\n            }\n            signal.addEventListener(\"abort\", abortAlgorithm);\n          }\n          function pipeLoop() {\n            return newPromise((resolveLoop, rejectLoop) => {\n              function next(done) {\n                if (done) {\n                  resolveLoop();\n                } else {\n                  PerformPromiseThen(pipeStep(), next, rejectLoop);\n                }\n              }\n              next(false);\n            });\n          }\n          function pipeStep() {\n            if (shuttingDown) {\n              return promiseResolvedWith(true);\n            }\n            return PerformPromiseThen(writer._readyPromise, () => {\n              return newPromise((resolveRead, rejectRead) => {\n                ReadableStreamDefaultReaderRead(reader, {\n                  _chunkSteps: (chunk) => {\n                    currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop2);\n                    resolveRead(false);\n                  },\n                  _closeSteps: () => resolveRead(true),\n                  _errorSteps: rejectRead\n                });\n              });\n            });\n          }\n          isOrBecomesErrored(source, reader._closedPromise, (storedError) => {\n            if (!preventAbort) {\n              shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n            } else {\n              shutdown(true, storedError);\n            }\n          });\n          isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {\n            if (!preventCancel) {\n              shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n            } else {\n              shutdown(true, storedError);\n            }\n          });\n          isOrBecomesClosed(source, reader._closedPromise, () => {\n            if (!preventClose) {\n              shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n            } else {\n              shutdown();\n            }\n          });\n          if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === \"closed\") {\n            const destClosed = new TypeError(\"the destination writable stream closed before all data could be piped to it\");\n            if (!preventCancel) {\n              shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);\n            } else {\n              shutdown(true, destClosed);\n            }\n          }\n          setPromiseIsHandledToTrue(pipeLoop());\n          function waitForWritesToFinish() {\n            const oldCurrentWrite = currentWrite;\n            return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);\n          }\n          function isOrBecomesErrored(stream, promise, action) {\n            if (stream._state === \"errored\") {\n              action(stream._storedError);\n            } else {\n              uponRejection(promise, action);\n            }\n          }\n          function isOrBecomesClosed(stream, promise, action) {\n            if (stream._state === \"closed\") {\n              action();\n            } else {\n              uponFulfillment(promise, action);\n            }\n          }\n          function shutdownWithAction(action, originalIsError, originalError) {\n            if (shuttingDown) {\n              return;\n            }\n            shuttingDown = true;\n            if (dest._state === \"writable\" && !WritableStreamCloseQueuedOrInFlight(dest)) {\n              uponFulfillment(waitForWritesToFinish(), doTheRest);\n            } else {\n              doTheRest();\n            }\n            function doTheRest() {\n              uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));\n            }\n          }\n          function shutdown(isError, error) {\n            if (shuttingDown) {\n              return;\n            }\n            shuttingDown = true;\n            if (dest._state === \"writable\" && !WritableStreamCloseQueuedOrInFlight(dest)) {\n              uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));\n            } else {\n              finalize(isError, error);\n            }\n          }\n          function finalize(isError, error) {\n            WritableStreamDefaultWriterRelease(writer);\n            ReadableStreamReaderGenericRelease(reader);\n            if (signal !== void 0) {\n              signal.removeEventListener(\"abort\", abortAlgorithm);\n            }\n            if (isError) {\n              reject(error);\n            } else {\n              resolve(void 0);\n            }\n          }\n        });\n      }\n      class ReadableStreamDefaultController {\n        constructor() {\n          throw new TypeError(\"Illegal constructor\");\n        }\n        get desiredSize() {\n          if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1(\"desiredSize\");\n          }\n          return ReadableStreamDefaultControllerGetDesiredSize(this);\n        }\n        close() {\n          if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1(\"close\");\n          }\n          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n            throw new TypeError(\"The stream is not in a state that permits close\");\n          }\n          ReadableStreamDefaultControllerClose(this);\n        }\n        enqueue(chunk = void 0) {\n          if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1(\"enqueue\");\n          }\n          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n            throw new TypeError(\"The stream is not in a state that permits enqueue\");\n          }\n          return ReadableStreamDefaultControllerEnqueue(this, chunk);\n        }\n        error(e2 = void 0) {\n          if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1(\"error\");\n          }\n          ReadableStreamDefaultControllerError(this, e2);\n        }\n        [CancelSteps](reason) {\n          ResetQueue(this);\n          const result = this._cancelAlgorithm(reason);\n          ReadableStreamDefaultControllerClearAlgorithms(this);\n          return result;\n        }\n        [PullSteps](readRequest) {\n          const stream = this._controlledReadableStream;\n          if (this._queue.length > 0) {\n            const chunk = DequeueValue(this);\n            if (this._closeRequested && this._queue.length === 0) {\n              ReadableStreamDefaultControllerClearAlgorithms(this);\n              ReadableStreamClose(stream);\n            } else {\n              ReadableStreamDefaultControllerCallPullIfNeeded(this);\n            }\n            readRequest._chunkSteps(chunk);\n          } else {\n            ReadableStreamAddReadRequest(stream, readRequest);\n            ReadableStreamDefaultControllerCallPullIfNeeded(this);\n          }\n        }\n      }\n      Object.defineProperties(ReadableStreamDefaultController.prototype, {\n        close: { enumerable: true },\n        enqueue: { enumerable: true },\n        error: { enumerable: true },\n        desiredSize: { enumerable: true }\n      });\n      if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n          value: \"ReadableStreamDefaultController\",\n          configurable: true\n        });\n      }\n      function IsReadableStreamDefaultController(x2) {\n        if (!typeIsObject(x2)) {\n          return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x2, \"_controlledReadableStream\")) {\n          return false;\n        }\n        return x2 instanceof ReadableStreamDefaultController;\n      }\n      function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n        const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n        if (!shouldPull) {\n          return;\n        }\n        if (controller._pulling) {\n          controller._pullAgain = true;\n          return;\n        }\n        controller._pulling = true;\n        const pullPromise = controller._pullAlgorithm();\n        uponPromise(pullPromise, () => {\n          controller._pulling = false;\n          if (controller._pullAgain) {\n            controller._pullAgain = false;\n            ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n          }\n        }, (e2) => {\n          ReadableStreamDefaultControllerError(controller, e2);\n        });\n      }\n      function ReadableStreamDefaultControllerShouldCallPull(controller) {\n        const stream = controller._controlledReadableStream;\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n          return false;\n        }\n        if (!controller._started) {\n          return false;\n        }\n        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n          return true;\n        }\n        const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n        if (desiredSize > 0) {\n          return true;\n        }\n        return false;\n      }\n      function ReadableStreamDefaultControllerClearAlgorithms(controller) {\n        controller._pullAlgorithm = void 0;\n        controller._cancelAlgorithm = void 0;\n        controller._strategySizeAlgorithm = void 0;\n      }\n      function ReadableStreamDefaultControllerClose(controller) {\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n          return;\n        }\n        const stream = controller._controlledReadableStream;\n        controller._closeRequested = true;\n        if (controller._queue.length === 0) {\n          ReadableStreamDefaultControllerClearAlgorithms(controller);\n          ReadableStreamClose(stream);\n        }\n      }\n      function ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n          return;\n        }\n        const stream = controller._controlledReadableStream;\n        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n          ReadableStreamFulfillReadRequest(stream, chunk, false);\n        } else {\n          let chunkSize;\n          try {\n            chunkSize = controller._strategySizeAlgorithm(chunk);\n          } catch (chunkSizeE) {\n            ReadableStreamDefaultControllerError(controller, chunkSizeE);\n            throw chunkSizeE;\n          }\n          try {\n            EnqueueValueWithSize(controller, chunk, chunkSize);\n          } catch (enqueueE) {\n            ReadableStreamDefaultControllerError(controller, enqueueE);\n            throw enqueueE;\n          }\n        }\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      }\n      function ReadableStreamDefaultControllerError(controller, e2) {\n        const stream = controller._controlledReadableStream;\n        if (stream._state !== \"readable\") {\n          return;\n        }\n        ResetQueue(controller);\n        ReadableStreamDefaultControllerClearAlgorithms(controller);\n        ReadableStreamError(stream, e2);\n      }\n      function ReadableStreamDefaultControllerGetDesiredSize(controller) {\n        const state = controller._controlledReadableStream._state;\n        if (state === \"errored\") {\n          return null;\n        }\n        if (state === \"closed\") {\n          return 0;\n        }\n        return controller._strategyHWM - controller._queueTotalSize;\n      }\n      function ReadableStreamDefaultControllerHasBackpressure(controller) {\n        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n          return false;\n        }\n        return true;\n      }\n      function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n        const state = controller._controlledReadableStream._state;\n        if (!controller._closeRequested && state === \"readable\") {\n          return true;\n        }\n        return false;\n      }\n      function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n        controller._controlledReadableStream = stream;\n        controller._queue = void 0;\n        controller._queueTotalSize = void 0;\n        ResetQueue(controller);\n        controller._started = false;\n        controller._closeRequested = false;\n        controller._pullAgain = false;\n        controller._pulling = false;\n        controller._strategySizeAlgorithm = sizeAlgorithm;\n        controller._strategyHWM = highWaterMark;\n        controller._pullAlgorithm = pullAlgorithm;\n        controller._cancelAlgorithm = cancelAlgorithm;\n        stream._readableStreamController = controller;\n        const startResult = startAlgorithm();\n        uponPromise(promiseResolvedWith(startResult), () => {\n          controller._started = true;\n          ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n        }, (r2) => {\n          ReadableStreamDefaultControllerError(controller, r2);\n        });\n      }\n      function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\n        const controller = Object.create(ReadableStreamDefaultController.prototype);\n        let startAlgorithm = () => void 0;\n        let pullAlgorithm = () => promiseResolvedWith(void 0);\n        let cancelAlgorithm = () => promiseResolvedWith(void 0);\n        if (underlyingSource.start !== void 0) {\n          startAlgorithm = () => underlyingSource.start(controller);\n        }\n        if (underlyingSource.pull !== void 0) {\n          pullAlgorithm = () => underlyingSource.pull(controller);\n        }\n        if (underlyingSource.cancel !== void 0) {\n          cancelAlgorithm = (reason) => underlyingSource.cancel(reason);\n        }\n        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n      }\n      function defaultControllerBrandCheckException$1(name) {\n        return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n      }\n      function ReadableStreamTee(stream, cloneForBranch2) {\n        if (IsReadableByteStreamController(stream._readableStreamController)) {\n          return ReadableByteStreamTee(stream);\n        }\n        return ReadableStreamDefaultTee(stream);\n      }\n      function ReadableStreamDefaultTee(stream, cloneForBranch2) {\n        const reader = AcquireReadableStreamDefaultReader(stream);\n        let reading = false;\n        let readAgain = false;\n        let canceled1 = false;\n        let canceled2 = false;\n        let reason1;\n        let reason2;\n        let branch1;\n        let branch2;\n        let resolveCancelPromise;\n        const cancelPromise = newPromise((resolve) => {\n          resolveCancelPromise = resolve;\n        });\n        function pullAlgorithm() {\n          if (reading) {\n            readAgain = true;\n            return promiseResolvedWith(void 0);\n          }\n          reading = true;\n          const readRequest = {\n            _chunkSteps: (chunk) => {\n              queueMicrotask(() => {\n                readAgain = false;\n                const chunk1 = chunk;\n                const chunk2 = chunk;\n                if (!canceled1) {\n                  ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);\n                }\n                if (!canceled2) {\n                  ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n                }\n                reading = false;\n                if (readAgain) {\n                  pullAlgorithm();\n                }\n              });\n            },\n            _closeSteps: () => {\n              reading = false;\n              if (!canceled1) {\n                ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n              }\n              if (!canceled2) {\n                ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n              }\n              if (!canceled1 || !canceled2) {\n                resolveCancelPromise(void 0);\n              }\n            },\n            _errorSteps: () => {\n              reading = false;\n            }\n          };\n          ReadableStreamDefaultReaderRead(reader, readRequest);\n          return promiseResolvedWith(void 0);\n        }\n        function cancel1Algorithm(reason) {\n          canceled1 = true;\n          reason1 = reason;\n          if (canceled2) {\n            const compositeReason = CreateArrayFromList([reason1, reason2]);\n            const cancelResult = ReadableStreamCancel(stream, compositeReason);\n            resolveCancelPromise(cancelResult);\n          }\n          return cancelPromise;\n        }\n        function cancel2Algorithm(reason) {\n          canceled2 = true;\n          reason2 = reason;\n          if (canceled1) {\n            const compositeReason = CreateArrayFromList([reason1, reason2]);\n            const cancelResult = ReadableStreamCancel(stream, compositeReason);\n            resolveCancelPromise(cancelResult);\n          }\n          return cancelPromise;\n        }\n        function startAlgorithm() {\n        }\n        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n        uponRejection(reader._closedPromise, (r2) => {\n          ReadableStreamDefaultControllerError(branch1._readableStreamController, r2);\n          ReadableStreamDefaultControllerError(branch2._readableStreamController, r2);\n          if (!canceled1 || !canceled2) {\n            resolveCancelPromise(void 0);\n          }\n        });\n        return [branch1, branch2];\n      }\n      function ReadableByteStreamTee(stream) {\n        let reader = AcquireReadableStreamDefaultReader(stream);\n        let reading = false;\n        let readAgainForBranch1 = false;\n        let readAgainForBranch2 = false;\n        let canceled1 = false;\n        let canceled2 = false;\n        let reason1;\n        let reason2;\n        let branch1;\n        let branch2;\n        let resolveCancelPromise;\n        const cancelPromise = newPromise((resolve) => {\n          resolveCancelPromise = resolve;\n        });\n        function forwardReaderError(thisReader) {\n          uponRejection(thisReader._closedPromise, (r2) => {\n            if (thisReader !== reader) {\n              return;\n            }\n            ReadableByteStreamControllerError(branch1._readableStreamController, r2);\n            ReadableByteStreamControllerError(branch2._readableStreamController, r2);\n            if (!canceled1 || !canceled2) {\n              resolveCancelPromise(void 0);\n            }\n          });\n        }\n        function pullWithDefaultReader() {\n          if (IsReadableStreamBYOBReader(reader)) {\n            ReadableStreamReaderGenericRelease(reader);\n            reader = AcquireReadableStreamDefaultReader(stream);\n            forwardReaderError(reader);\n          }\n          const readRequest = {\n            _chunkSteps: (chunk) => {\n              queueMicrotask(() => {\n                readAgainForBranch1 = false;\n                readAgainForBranch2 = false;\n                const chunk1 = chunk;\n                let chunk2 = chunk;\n                if (!canceled1 && !canceled2) {\n                  try {\n                    chunk2 = CloneAsUint8Array(chunk);\n                  } catch (cloneE) {\n                    ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);\n                    ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);\n                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                    return;\n                  }\n                }\n                if (!canceled1) {\n                  ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);\n                }\n                if (!canceled2) {\n                  ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n                }\n                reading = false;\n                if (readAgainForBranch1) {\n                  pull1Algorithm();\n                } else if (readAgainForBranch2) {\n                  pull2Algorithm();\n                }\n              });\n            },\n            _closeSteps: () => {\n              reading = false;\n              if (!canceled1) {\n                ReadableByteStreamControllerClose(branch1._readableStreamController);\n              }\n              if (!canceled2) {\n                ReadableByteStreamControllerClose(branch2._readableStreamController);\n              }\n              if (branch1._readableStreamController._pendingPullIntos.length > 0) {\n                ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);\n              }\n              if (branch2._readableStreamController._pendingPullIntos.length > 0) {\n                ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);\n              }\n              if (!canceled1 || !canceled2) {\n                resolveCancelPromise(void 0);\n              }\n            },\n            _errorSteps: () => {\n              reading = false;\n            }\n          };\n          ReadableStreamDefaultReaderRead(reader, readRequest);\n        }\n        function pullWithBYOBReader(view, forBranch2) {\n          if (IsReadableStreamDefaultReader(reader)) {\n            ReadableStreamReaderGenericRelease(reader);\n            reader = AcquireReadableStreamBYOBReader(stream);\n            forwardReaderError(reader);\n          }\n          const byobBranch = forBranch2 ? branch2 : branch1;\n          const otherBranch = forBranch2 ? branch1 : branch2;\n          const readIntoRequest = {\n            _chunkSteps: (chunk) => {\n              queueMicrotask(() => {\n                readAgainForBranch1 = false;\n                readAgainForBranch2 = false;\n                const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                if (!otherCanceled) {\n                  let clonedChunk;\n                  try {\n                    clonedChunk = CloneAsUint8Array(chunk);\n                  } catch (cloneE) {\n                    ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);\n                    ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);\n                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                    return;\n                  }\n                  if (!byobCanceled) {\n                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                  }\n                  ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);\n                } else if (!byobCanceled) {\n                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                }\n                reading = false;\n                if (readAgainForBranch1) {\n                  pull1Algorithm();\n                } else if (readAgainForBranch2) {\n                  pull2Algorithm();\n                }\n              });\n            },\n            _closeSteps: (chunk) => {\n              reading = false;\n              const byobCanceled = forBranch2 ? canceled2 : canceled1;\n              const otherCanceled = forBranch2 ? canceled1 : canceled2;\n              if (!byobCanceled) {\n                ReadableByteStreamControllerClose(byobBranch._readableStreamController);\n              }\n              if (!otherCanceled) {\n                ReadableByteStreamControllerClose(otherBranch._readableStreamController);\n              }\n              if (chunk !== void 0) {\n                if (!byobCanceled) {\n                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                }\n                if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {\n                  ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);\n                }\n              }\n              if (!byobCanceled || !otherCanceled) {\n                resolveCancelPromise(void 0);\n              }\n            },\n            _errorSteps: () => {\n              reading = false;\n            }\n          };\n          ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);\n        }\n        function pull1Algorithm() {\n          if (reading) {\n            readAgainForBranch1 = true;\n            return promiseResolvedWith(void 0);\n          }\n          reading = true;\n          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n          if (byobRequest === null) {\n            pullWithDefaultReader();\n          } else {\n            pullWithBYOBReader(byobRequest._view, false);\n          }\n          return promiseResolvedWith(void 0);\n        }\n        function pull2Algorithm() {\n          if (reading) {\n            readAgainForBranch2 = true;\n            return promiseResolvedWith(void 0);\n          }\n          reading = true;\n          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n          if (byobRequest === null) {\n            pullWithDefaultReader();\n          } else {\n            pullWithBYOBReader(byobRequest._view, true);\n          }\n          return promiseResolvedWith(void 0);\n        }\n        function cancel1Algorithm(reason) {\n          canceled1 = true;\n          reason1 = reason;\n          if (canceled2) {\n            const compositeReason = CreateArrayFromList([reason1, reason2]);\n            const cancelResult = ReadableStreamCancel(stream, compositeReason);\n            resolveCancelPromise(cancelResult);\n          }\n          return cancelPromise;\n        }\n        function cancel2Algorithm(reason) {\n          canceled2 = true;\n          reason2 = reason;\n          if (canceled1) {\n            const compositeReason = CreateArrayFromList([reason1, reason2]);\n            const cancelResult = ReadableStreamCancel(stream, compositeReason);\n            resolveCancelPromise(cancelResult);\n          }\n          return cancelPromise;\n        }\n        function startAlgorithm() {\n          return;\n        }\n        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n        forwardReaderError(reader);\n        return [branch1, branch2];\n      }\n      function convertUnderlyingDefaultOrByteSource(source, context) {\n        assertDictionary(source, context);\n        const original = source;\n        const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;\n        const cancel = original === null || original === void 0 ? void 0 : original.cancel;\n        const pull = original === null || original === void 0 ? void 0 : original.pull;\n        const start = original === null || original === void 0 ? void 0 : original.start;\n        const type = original === null || original === void 0 ? void 0 : original.type;\n        return {\n          autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),\n          cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),\n          pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),\n          start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),\n          type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)\n        };\n      }\n      function convertUnderlyingSourceCancelCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (reason) => promiseCall(fn, original, [reason]);\n      }\n      function convertUnderlyingSourcePullCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller) => promiseCall(fn, original, [controller]);\n      }\n      function convertUnderlyingSourceStartCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller) => reflectCall(fn, original, [controller]);\n      }\n      function convertReadableStreamType(type, context) {\n        type = `${type}`;\n        if (type !== \"bytes\") {\n          throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\n        }\n        return type;\n      }\n      function convertReaderOptions(options, context) {\n        assertDictionary(options, context);\n        const mode = options === null || options === void 0 ? void 0 : options.mode;\n        return {\n          mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\n        };\n      }\n      function convertReadableStreamReaderMode(mode, context) {\n        mode = `${mode}`;\n        if (mode !== \"byob\") {\n          throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\n        }\n        return mode;\n      }\n      function convertIteratorOptions(options, context) {\n        assertDictionary(options, context);\n        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n        return { preventCancel: Boolean(preventCancel) };\n      }\n      function convertPipeOptions(options, context) {\n        assertDictionary(options, context);\n        const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;\n        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n        const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;\n        const signal = options === null || options === void 0 ? void 0 : options.signal;\n        if (signal !== void 0) {\n          assertAbortSignal(signal, `${context} has member 'signal' that`);\n        }\n        return {\n          preventAbort: Boolean(preventAbort),\n          preventCancel: Boolean(preventCancel),\n          preventClose: Boolean(preventClose),\n          signal\n        };\n      }\n      function assertAbortSignal(signal, context) {\n        if (!isAbortSignal2(signal)) {\n          throw new TypeError(`${context} is not an AbortSignal.`);\n        }\n      }\n      function convertReadableWritablePair(pair, context) {\n        assertDictionary(pair, context);\n        const readable = pair === null || pair === void 0 ? void 0 : pair.readable;\n        assertRequiredField(readable, \"readable\", \"ReadableWritablePair\");\n        assertReadableStream(readable, `${context} has member 'readable' that`);\n        const writable = pair === null || pair === void 0 ? void 0 : pair.writable;\n        assertRequiredField(writable, \"writable\", \"ReadableWritablePair\");\n        assertWritableStream(writable, `${context} has member 'writable' that`);\n        return { readable, writable };\n      }\n      class ReadableStream2 {\n        constructor(rawUnderlyingSource = {}, rawStrategy = {}) {\n          if (rawUnderlyingSource === void 0) {\n            rawUnderlyingSource = null;\n          } else {\n            assertObject(rawUnderlyingSource, \"First parameter\");\n          }\n          const strategy = convertQueuingStrategy(rawStrategy, \"Second parameter\");\n          const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, \"First parameter\");\n          InitializeReadableStream(this);\n          if (underlyingSource.type === \"bytes\") {\n            if (strategy.size !== void 0) {\n              throw new RangeError(\"The strategy for a byte stream cannot have a size function\");\n            }\n            const highWaterMark = ExtractHighWaterMark(strategy, 0);\n            SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n          } else {\n            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n            const highWaterMark = ExtractHighWaterMark(strategy, 1);\n            SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n          }\n        }\n        get locked() {\n          if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1(\"locked\");\n          }\n          return IsReadableStreamLocked(this);\n        }\n        cancel(reason = void 0) {\n          if (!IsReadableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$1(\"cancel\"));\n          }\n          if (IsReadableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError(\"Cannot cancel a stream that already has a reader\"));\n          }\n          return ReadableStreamCancel(this, reason);\n        }\n        getReader(rawOptions = void 0) {\n          if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1(\"getReader\");\n          }\n          const options = convertReaderOptions(rawOptions, \"First parameter\");\n          if (options.mode === void 0) {\n            return AcquireReadableStreamDefaultReader(this);\n          }\n          return AcquireReadableStreamBYOBReader(this);\n        }\n        pipeThrough(rawTransform, rawOptions = {}) {\n          if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1(\"pipeThrough\");\n          }\n          assertRequiredArgument(rawTransform, 1, \"pipeThrough\");\n          const transform = convertReadableWritablePair(rawTransform, \"First parameter\");\n          const options = convertPipeOptions(rawOptions, \"Second parameter\");\n          if (IsReadableStreamLocked(this)) {\n            throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream\");\n          }\n          if (IsWritableStreamLocked(transform.writable)) {\n            throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream\");\n          }\n          const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n          setPromiseIsHandledToTrue(promise);\n          return transform.readable;\n        }\n        pipeTo(destination, rawOptions = {}) {\n          if (!IsReadableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$1(\"pipeTo\"));\n          }\n          if (destination === void 0) {\n            return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\n          }\n          if (!IsWritableStream(destination)) {\n            return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));\n          }\n          let options;\n          try {\n            options = convertPipeOptions(rawOptions, \"Second parameter\");\n          } catch (e2) {\n            return promiseRejectedWith(e2);\n          }\n          if (IsReadableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream\"));\n          }\n          if (IsWritableStreamLocked(destination)) {\n            return promiseRejectedWith(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream\"));\n          }\n          return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n        }\n        tee() {\n          if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1(\"tee\");\n          }\n          const branches = ReadableStreamTee(this);\n          return CreateArrayFromList(branches);\n        }\n        values(rawOptions = void 0) {\n          if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1(\"values\");\n          }\n          const options = convertIteratorOptions(rawOptions, \"First parameter\");\n          return AcquireReadableStreamAsyncIterator(this, options.preventCancel);\n        }\n      }\n      Object.defineProperties(ReadableStream2.prototype, {\n        cancel: { enumerable: true },\n        getReader: { enumerable: true },\n        pipeThrough: { enumerable: true },\n        pipeTo: { enumerable: true },\n        tee: { enumerable: true },\n        values: { enumerable: true },\n        locked: { enumerable: true }\n      });\n      if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {\n          value: \"ReadableStream\",\n          configurable: true\n        });\n      }\n      if (typeof SymbolPolyfill.asyncIterator === \"symbol\") {\n        Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {\n          value: ReadableStream2.prototype.values,\n          writable: true,\n          configurable: true\n        });\n      }\n      function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n        const stream = Object.create(ReadableStream2.prototype);\n        InitializeReadableStream(stream);\n        const controller = Object.create(ReadableStreamDefaultController.prototype);\n        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n        return stream;\n      }\n      function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {\n        const stream = Object.create(ReadableStream2.prototype);\n        InitializeReadableStream(stream);\n        const controller = Object.create(ReadableByteStreamController.prototype);\n        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);\n        return stream;\n      }\n      function InitializeReadableStream(stream) {\n        stream._state = \"readable\";\n        stream._reader = void 0;\n        stream._storedError = void 0;\n        stream._disturbed = false;\n      }\n      function IsReadableStream(x2) {\n        if (!typeIsObject(x2)) {\n          return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x2, \"_readableStreamController\")) {\n          return false;\n        }\n        return x2 instanceof ReadableStream2;\n      }\n      function IsReadableStreamLocked(stream) {\n        if (stream._reader === void 0) {\n          return false;\n        }\n        return true;\n      }\n      function ReadableStreamCancel(stream, reason) {\n        stream._disturbed = true;\n        if (stream._state === \"closed\") {\n          return promiseResolvedWith(void 0);\n        }\n        if (stream._state === \"errored\") {\n          return promiseRejectedWith(stream._storedError);\n        }\n        ReadableStreamClose(stream);\n        const reader = stream._reader;\n        if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {\n          reader._readIntoRequests.forEach((readIntoRequest) => {\n            readIntoRequest._closeSteps(void 0);\n          });\n          reader._readIntoRequests = new SimpleQueue();\n        }\n        const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n        return transformPromiseWith(sourceCancelPromise, noop2);\n      }\n      function ReadableStreamClose(stream) {\n        stream._state = \"closed\";\n        const reader = stream._reader;\n        if (reader === void 0) {\n          return;\n        }\n        defaultReaderClosedPromiseResolve(reader);\n        if (IsReadableStreamDefaultReader(reader)) {\n          reader._readRequests.forEach((readRequest) => {\n            readRequest._closeSteps();\n          });\n          reader._readRequests = new SimpleQueue();\n        }\n      }\n      function ReadableStreamError(stream, e2) {\n        stream._state = \"errored\";\n        stream._storedError = e2;\n        const reader = stream._reader;\n        if (reader === void 0) {\n          return;\n        }\n        defaultReaderClosedPromiseReject(reader, e2);\n        if (IsReadableStreamDefaultReader(reader)) {\n          reader._readRequests.forEach((readRequest) => {\n            readRequest._errorSteps(e2);\n          });\n          reader._readRequests = new SimpleQueue();\n        } else {\n          reader._readIntoRequests.forEach((readIntoRequest) => {\n            readIntoRequest._errorSteps(e2);\n          });\n          reader._readIntoRequests = new SimpleQueue();\n        }\n      }\n      function streamBrandCheckException$1(name) {\n        return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n      }\n      function convertQueuingStrategyInit(init, context) {\n        assertDictionary(init, context);\n        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n        assertRequiredField(highWaterMark, \"highWaterMark\", \"QueuingStrategyInit\");\n        return {\n          highWaterMark: convertUnrestrictedDouble(highWaterMark)\n        };\n      }\n      const byteLengthSizeFunction = (chunk) => {\n        return chunk.byteLength;\n      };\n      Object.defineProperty(byteLengthSizeFunction, \"name\", {\n        value: \"size\",\n        configurable: true\n      });\n      class ByteLengthQueuingStrategy {\n        constructor(options) {\n          assertRequiredArgument(options, 1, \"ByteLengthQueuingStrategy\");\n          options = convertQueuingStrategyInit(options, \"First parameter\");\n          this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n        }\n        get highWaterMark() {\n          if (!IsByteLengthQueuingStrategy(this)) {\n            throw byteLengthBrandCheckException(\"highWaterMark\");\n          }\n          return this._byteLengthQueuingStrategyHighWaterMark;\n        }\n        get size() {\n          if (!IsByteLengthQueuingStrategy(this)) {\n            throw byteLengthBrandCheckException(\"size\");\n          }\n          return byteLengthSizeFunction;\n        }\n      }\n      Object.defineProperties(ByteLengthQueuingStrategy.prototype, {\n        highWaterMark: { enumerable: true },\n        size: { enumerable: true }\n      });\n      if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n          value: \"ByteLengthQueuingStrategy\",\n          configurable: true\n        });\n      }\n      function byteLengthBrandCheckException(name) {\n        return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\n      }\n      function IsByteLengthQueuingStrategy(x2) {\n        if (!typeIsObject(x2)) {\n          return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x2, \"_byteLengthQueuingStrategyHighWaterMark\")) {\n          return false;\n        }\n        return x2 instanceof ByteLengthQueuingStrategy;\n      }\n      const countSizeFunction = () => {\n        return 1;\n      };\n      Object.defineProperty(countSizeFunction, \"name\", {\n        value: \"size\",\n        configurable: true\n      });\n      class CountQueuingStrategy {\n        constructor(options) {\n          assertRequiredArgument(options, 1, \"CountQueuingStrategy\");\n          options = convertQueuingStrategyInit(options, \"First parameter\");\n          this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n        }\n        get highWaterMark() {\n          if (!IsCountQueuingStrategy(this)) {\n            throw countBrandCheckException(\"highWaterMark\");\n          }\n          return this._countQueuingStrategyHighWaterMark;\n        }\n        get size() {\n          if (!IsCountQueuingStrategy(this)) {\n            throw countBrandCheckException(\"size\");\n          }\n          return countSizeFunction;\n        }\n      }\n      Object.defineProperties(CountQueuingStrategy.prototype, {\n        highWaterMark: { enumerable: true },\n        size: { enumerable: true }\n      });\n      if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n          value: \"CountQueuingStrategy\",\n          configurable: true\n        });\n      }\n      function countBrandCheckException(name) {\n        return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\n      }\n      function IsCountQueuingStrategy(x2) {\n        if (!typeIsObject(x2)) {\n          return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x2, \"_countQueuingStrategyHighWaterMark\")) {\n          return false;\n        }\n        return x2 instanceof CountQueuingStrategy;\n      }\n      function convertTransformer(original, context) {\n        assertDictionary(original, context);\n        const flush = original === null || original === void 0 ? void 0 : original.flush;\n        const readableType = original === null || original === void 0 ? void 0 : original.readableType;\n        const start = original === null || original === void 0 ? void 0 : original.start;\n        const transform = original === null || original === void 0 ? void 0 : original.transform;\n        const writableType = original === null || original === void 0 ? void 0 : original.writableType;\n        return {\n          flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),\n          readableType,\n          start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),\n          transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),\n          writableType\n        };\n      }\n      function convertTransformerFlushCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller) => promiseCall(fn, original, [controller]);\n      }\n      function convertTransformerStartCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller) => reflectCall(fn, original, [controller]);\n      }\n      function convertTransformerTransformCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);\n      }\n      class TransformStream {\n        constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {\n          if (rawTransformer === void 0) {\n            rawTransformer = null;\n          }\n          const writableStrategy = convertQueuingStrategy(rawWritableStrategy, \"Second parameter\");\n          const readableStrategy = convertQueuingStrategy(rawReadableStrategy, \"Third parameter\");\n          const transformer = convertTransformer(rawTransformer, \"First parameter\");\n          if (transformer.readableType !== void 0) {\n            throw new RangeError(\"Invalid readableType specified\");\n          }\n          if (transformer.writableType !== void 0) {\n            throw new RangeError(\"Invalid writableType specified\");\n          }\n          const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n          const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n          const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n          const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n          let startPromise_resolve;\n          const startPromise = newPromise((resolve) => {\n            startPromise_resolve = resolve;\n          });\n          InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n          SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n          if (transformer.start !== void 0) {\n            startPromise_resolve(transformer.start(this._transformStreamController));\n          } else {\n            startPromise_resolve(void 0);\n          }\n        }\n        get readable() {\n          if (!IsTransformStream(this)) {\n            throw streamBrandCheckException(\"readable\");\n          }\n          return this._readable;\n        }\n        get writable() {\n          if (!IsTransformStream(this)) {\n            throw streamBrandCheckException(\"writable\");\n          }\n          return this._writable;\n        }\n      }\n      Object.defineProperties(TransformStream.prototype, {\n        readable: { enumerable: true },\n        writable: { enumerable: true }\n      });\n      if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {\n          value: \"TransformStream\",\n          configurable: true\n        });\n      }\n      function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n        function startAlgorithm() {\n          return startPromise;\n        }\n        function writeAlgorithm(chunk) {\n          return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n        }\n        function abortAlgorithm(reason) {\n          return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n        }\n        function closeAlgorithm() {\n          return TransformStreamDefaultSinkCloseAlgorithm(stream);\n        }\n        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n        function pullAlgorithm() {\n          return TransformStreamDefaultSourcePullAlgorithm(stream);\n        }\n        function cancelAlgorithm(reason) {\n          TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n          return promiseResolvedWith(void 0);\n        }\n        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n        stream._backpressure = void 0;\n        stream._backpressureChangePromise = void 0;\n        stream._backpressureChangePromise_resolve = void 0;\n        TransformStreamSetBackpressure(stream, true);\n        stream._transformStreamController = void 0;\n      }\n      function IsTransformStream(x2) {\n        if (!typeIsObject(x2)) {\n          return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x2, \"_transformStreamController\")) {\n          return false;\n        }\n        return x2 instanceof TransformStream;\n      }\n      function TransformStreamError(stream, e2) {\n        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e2);\n        TransformStreamErrorWritableAndUnblockWrite(stream, e2);\n      }\n      function TransformStreamErrorWritableAndUnblockWrite(stream, e2) {\n        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e2);\n        if (stream._backpressure) {\n          TransformStreamSetBackpressure(stream, false);\n        }\n      }\n      function TransformStreamSetBackpressure(stream, backpressure) {\n        if (stream._backpressureChangePromise !== void 0) {\n          stream._backpressureChangePromise_resolve();\n        }\n        stream._backpressureChangePromise = newPromise((resolve) => {\n          stream._backpressureChangePromise_resolve = resolve;\n        });\n        stream._backpressure = backpressure;\n      }\n      class TransformStreamDefaultController {\n        constructor() {\n          throw new TypeError(\"Illegal constructor\");\n        }\n        get desiredSize() {\n          if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException(\"desiredSize\");\n          }\n          const readableController = this._controlledTransformStream._readable._readableStreamController;\n          return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n        }\n        enqueue(chunk = void 0) {\n          if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException(\"enqueue\");\n          }\n          TransformStreamDefaultControllerEnqueue(this, chunk);\n        }\n        error(reason = void 0) {\n          if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException(\"error\");\n          }\n          TransformStreamDefaultControllerError(this, reason);\n        }\n        terminate() {\n          if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException(\"terminate\");\n          }\n          TransformStreamDefaultControllerTerminate(this);\n        }\n      }\n      Object.defineProperties(TransformStreamDefaultController.prototype, {\n        enqueue: { enumerable: true },\n        error: { enumerable: true },\n        terminate: { enumerable: true },\n        desiredSize: { enumerable: true }\n      });\n      if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n          value: \"TransformStreamDefaultController\",\n          configurable: true\n        });\n      }\n      function IsTransformStreamDefaultController(x2) {\n        if (!typeIsObject(x2)) {\n          return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x2, \"_controlledTransformStream\")) {\n          return false;\n        }\n        return x2 instanceof TransformStreamDefaultController;\n      }\n      function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n        controller._controlledTransformStream = stream;\n        stream._transformStreamController = controller;\n        controller._transformAlgorithm = transformAlgorithm;\n        controller._flushAlgorithm = flushAlgorithm;\n      }\n      function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n        const controller = Object.create(TransformStreamDefaultController.prototype);\n        let transformAlgorithm = (chunk) => {\n          try {\n            TransformStreamDefaultControllerEnqueue(controller, chunk);\n            return promiseResolvedWith(void 0);\n          } catch (transformResultE) {\n            return promiseRejectedWith(transformResultE);\n          }\n        };\n        let flushAlgorithm = () => promiseResolvedWith(void 0);\n        if (transformer.transform !== void 0) {\n          transformAlgorithm = (chunk) => transformer.transform(chunk, controller);\n        }\n        if (transformer.flush !== void 0) {\n          flushAlgorithm = () => transformer.flush(controller);\n        }\n        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n      }\n      function TransformStreamDefaultControllerClearAlgorithms(controller) {\n        controller._transformAlgorithm = void 0;\n        controller._flushAlgorithm = void 0;\n      }\n      function TransformStreamDefaultControllerEnqueue(controller, chunk) {\n        const stream = controller._controlledTransformStream;\n        const readableController = stream._readable._readableStreamController;\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n          throw new TypeError(\"Readable side is not in a state that permits enqueue\");\n        }\n        try {\n          ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n        } catch (e2) {\n          TransformStreamErrorWritableAndUnblockWrite(stream, e2);\n          throw stream._readable._storedError;\n        }\n        const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n        if (backpressure !== stream._backpressure) {\n          TransformStreamSetBackpressure(stream, true);\n        }\n      }\n      function TransformStreamDefaultControllerError(controller, e2) {\n        TransformStreamError(controller._controlledTransformStream, e2);\n      }\n      function TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n        const transformPromise = controller._transformAlgorithm(chunk);\n        return transformPromiseWith(transformPromise, void 0, (r2) => {\n          TransformStreamError(controller._controlledTransformStream, r2);\n          throw r2;\n        });\n      }\n      function TransformStreamDefaultControllerTerminate(controller) {\n        const stream = controller._controlledTransformStream;\n        const readableController = stream._readable._readableStreamController;\n        ReadableStreamDefaultControllerClose(readableController);\n        const error = new TypeError(\"TransformStream terminated\");\n        TransformStreamErrorWritableAndUnblockWrite(stream, error);\n      }\n      function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n        const controller = stream._transformStreamController;\n        if (stream._backpressure) {\n          const backpressureChangePromise = stream._backpressureChangePromise;\n          return transformPromiseWith(backpressureChangePromise, () => {\n            const writable = stream._writable;\n            const state = writable._state;\n            if (state === \"erroring\") {\n              throw writable._storedError;\n            }\n            return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n          });\n        }\n        return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n      }\n      function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n        TransformStreamError(stream, reason);\n        return promiseResolvedWith(void 0);\n      }\n      function TransformStreamDefaultSinkCloseAlgorithm(stream) {\n        const readable = stream._readable;\n        const controller = stream._transformStreamController;\n        const flushPromise = controller._flushAlgorithm();\n        TransformStreamDefaultControllerClearAlgorithms(controller);\n        return transformPromiseWith(flushPromise, () => {\n          if (readable._state === \"errored\") {\n            throw readable._storedError;\n          }\n          ReadableStreamDefaultControllerClose(readable._readableStreamController);\n        }, (r2) => {\n          TransformStreamError(stream, r2);\n          throw readable._storedError;\n        });\n      }\n      function TransformStreamDefaultSourcePullAlgorithm(stream) {\n        TransformStreamSetBackpressure(stream, false);\n        return stream._backpressureChangePromise;\n      }\n      function defaultControllerBrandCheckException(name) {\n        return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n      }\n      function streamBrandCheckException(name) {\n        return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);\n      }\n      exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;\n      exports2.CountQueuingStrategy = CountQueuingStrategy;\n      exports2.ReadableByteStreamController = ReadableByteStreamController;\n      exports2.ReadableStream = ReadableStream2;\n      exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader;\n      exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;\n      exports2.ReadableStreamDefaultController = ReadableStreamDefaultController;\n      exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader;\n      exports2.TransformStream = TransformStream;\n      exports2.TransformStreamDefaultController = TransformStreamDefaultController;\n      exports2.WritableStream = WritableStream;\n      exports2.WritableStreamDefaultController = WritableStreamDefaultController;\n      exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter;\n      Object.defineProperty(exports2, \"__esModule\", { value: true });\n    });\n  }\n});\n\n// node_modules/fetch-blob/streams.cjs\nvar require_streams = __commonJS({\n  \"node_modules/fetch-blob/streams.cjs\"() {\n    var POOL_SIZE2 = 65536;\n    if (!globalThis.ReadableStream) {\n      try {\n        const process2 = require(\"process\");\n        const { emitWarning } = process2;\n        try {\n          process2.emitWarning = () => {\n          };\n          Object.assign(globalThis, require(\"stream/web\"));\n          process2.emitWarning = emitWarning;\n        } catch (error) {\n          process2.emitWarning = emitWarning;\n          throw error;\n        }\n      } catch (error) {\n        Object.assign(globalThis, require_ponyfill_es2018());\n      }\n    }\n    try {\n      const { Blob: Blob3 } = require(\"buffer\");\n      if (Blob3 && !Blob3.prototype.stream) {\n        Blob3.prototype.stream = function name(params) {\n          let position = 0;\n          const blob = this;\n          return new ReadableStream({\n            type: \"bytes\",\n            async pull(ctrl) {\n              const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE2));\n              const buffer = await chunk.arrayBuffer();\n              position += buffer.byteLength;\n              ctrl.enqueue(new Uint8Array(buffer));\n              if (position === blob.size) {\n                ctrl.close();\n              }\n            }\n          });\n        };\n      }\n    } catch (error) {\n    }\n  }\n});\n\n// node_modules/fetch-blob/index.js\nasync function* toIterator(parts, clone2 = true) {\n  for (const part of parts) {\n    if (\"stream\" in part) {\n      yield* part.stream();\n    } else if (ArrayBuffer.isView(part)) {\n      if (clone2) {\n        let position = part.byteOffset;\n        const end = part.byteOffset + part.byteLength;\n        while (position !== end) {\n          const size = Math.min(end - position, POOL_SIZE);\n          const chunk = part.buffer.slice(position, position + size);\n          position += chunk.byteLength;\n          yield new Uint8Array(chunk);\n        }\n      } else {\n        yield part;\n      }\n    } else {\n      let position = 0;\n      while (position !== part.size) {\n        const chunk = part.slice(position, Math.min(part.size, position + POOL_SIZE));\n        const buffer = await chunk.arrayBuffer();\n        position += buffer.byteLength;\n        yield new Uint8Array(buffer);\n      }\n    }\n  }\n}\nvar import_streams, POOL_SIZE, _Blob, Blob2, fetch_blob_default;\nvar init_fetch_blob = __esm({\n  \"node_modules/fetch-blob/index.js\"() {\n    import_streams = __toModule(require_streams());\n    POOL_SIZE = 65536;\n    _Blob = class Blob {\n      #parts = [];\n      #type = \"\";\n      #size = 0;\n      constructor(blobParts = [], options = {}) {\n        if (typeof blobParts !== \"object\" || blobParts === null) {\n          throw new TypeError(\"Failed to construct 'Blob': The provided value cannot be converted to a sequence.\");\n        }\n        if (typeof blobParts[Symbol.iterator] !== \"function\") {\n          throw new TypeError(\"Failed to construct 'Blob': The object must have a callable @@iterator property.\");\n        }\n        if (typeof options !== \"object\" && typeof options !== \"function\") {\n          throw new TypeError(\"Failed to construct 'Blob': parameter 2 cannot convert to dictionary.\");\n        }\n        if (options === null)\n          options = {};\n        const encoder = new TextEncoder();\n        for (const element of blobParts) {\n          let part;\n          if (ArrayBuffer.isView(element)) {\n            part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));\n          } else if (element instanceof ArrayBuffer) {\n            part = new Uint8Array(element.slice(0));\n          } else if (element instanceof Blob) {\n            part = element;\n          } else {\n            part = encoder.encode(element);\n          }\n          this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size;\n          this.#parts.push(part);\n        }\n        const type = options.type === void 0 ? \"\" : String(options.type);\n        this.#type = /^[\\x20-\\x7E]*$/.test(type) ? type : \"\";\n      }\n      get size() {\n        return this.#size;\n      }\n      get type() {\n        return this.#type;\n      }\n      async text() {\n        const decoder = new TextDecoder();\n        let str = \"\";\n        for await (const part of toIterator(this.#parts, false)) {\n          str += decoder.decode(part, { stream: true });\n        }\n        str += decoder.decode();\n        return str;\n      }\n      async arrayBuffer() {\n        const data = new Uint8Array(this.size);\n        let offset = 0;\n        for await (const chunk of toIterator(this.#parts, false)) {\n          data.set(chunk, offset);\n          offset += chunk.length;\n        }\n        return data.buffer;\n      }\n      stream() {\n        const it = toIterator(this.#parts, true);\n        return new globalThis.ReadableStream({\n          type: \"bytes\",\n          async pull(ctrl) {\n            const chunk = await it.next();\n            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);\n          },\n          async cancel() {\n            await it.return();\n          }\n        });\n      }\n      slice(start = 0, end = this.size, type = \"\") {\n        const { size } = this;\n        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);\n        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);\n        const span = Math.max(relativeEnd - relativeStart, 0);\n        const parts = this.#parts;\n        const blobParts = [];\n        let added = 0;\n        for (const part of parts) {\n          if (added >= span) {\n            break;\n          }\n          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n          if (relativeStart && size2 <= relativeStart) {\n            relativeStart -= size2;\n            relativeEnd -= size2;\n          } else {\n            let chunk;\n            if (ArrayBuffer.isView(part)) {\n              chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));\n              added += chunk.byteLength;\n            } else {\n              chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));\n              added += chunk.size;\n            }\n            relativeEnd -= size2;\n            blobParts.push(chunk);\n            relativeStart = 0;\n          }\n        }\n        const blob = new Blob([], { type: String(type).toLowerCase() });\n        blob.#size = span;\n        blob.#parts = blobParts;\n        return blob;\n      }\n      get [Symbol.toStringTag]() {\n        return \"Blob\";\n      }\n      static [Symbol.hasInstance](object) {\n        return object && typeof object === \"object\" && typeof object.constructor === \"function\" && (typeof object.stream === \"function\" || typeof object.arrayBuffer === \"function\") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);\n      }\n    };\n    Object.defineProperties(_Blob.prototype, {\n      size: { enumerable: true },\n      type: { enumerable: true },\n      slice: { enumerable: true }\n    });\n    Blob2 = _Blob;\n    fetch_blob_default = Blob2;\n  }\n});\n\n// node_modules/fetch-blob/file.js\nvar _File, File2, file_default;\nvar init_file = __esm({\n  \"node_modules/fetch-blob/file.js\"() {\n    init_fetch_blob();\n    _File = class File extends fetch_blob_default {\n      #lastModified = 0;\n      #name = \"\";\n      constructor(fileBits, fileName, options = {}) {\n        if (arguments.length < 2) {\n          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);\n        }\n        super(fileBits, options);\n        if (options === null)\n          options = {};\n        const lastModified = options.lastModified === void 0 ? Date.now() : Number(options.lastModified);\n        if (!Number.isNaN(lastModified)) {\n          this.#lastModified = lastModified;\n        }\n        this.#name = String(fileName);\n      }\n      get name() {\n        return this.#name;\n      }\n      get lastModified() {\n        return this.#lastModified;\n      }\n      get [Symbol.toStringTag]() {\n        return \"File\";\n      }\n    };\n    File2 = _File;\n    file_default = File2;\n  }\n});\n\n// node_modules/formdata-polyfill/esm.min.js\nfunction formDataToBlob(F2, B = fetch_blob_default) {\n  var b = `${r()}${r()}`.replace(/\\./g, \"\").slice(-28).padStart(32, \"-\"), c = [], p = `--${b}\\r\nContent-Disposition: form-data; name=\"`;\n  F2.forEach((v, n) => typeof v == \"string\" ? c.push(p + e(n) + `\"\\r\n\\r\n${v.replace(/\\r(?!\\n)|(?<!\\r)\\n/g, \"\\r\\n\")}\\r\n`) : c.push(p + e(n) + `\"; filename=\"${e(v.name, 1)}\"\\r\nContent-Type: ${v.type || \"application/octet-stream\"}\\r\n\\r\n`, v, \"\\r\\n\"));\n  c.push(`--${b}--`);\n  return new B(c, { type: \"multipart/form-data; boundary=\" + b });\n}\nvar t, i, h, r, m, f, e, x, FormData;\nvar init_esm_min = __esm({\n  \"node_modules/formdata-polyfill/esm.min.js\"() {\n    init_fetch_blob();\n    init_file();\n    ({ toStringTag: t, iterator: i, hasInstance: h } = Symbol);\n    r = Math.random;\n    m = \"append,set,get,getAll,delete,keys,values,entries,forEach,constructor\".split(\",\");\n    f = (a, b, c) => (a += \"\", /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== void 0 ? c + \"\" : b[t] == \"File\" ? b.name : \"blob\", a), b.name !== c || b[t] == \"blob\" ? new file_default([b], c, b) : b] : [a, b + \"\"]);\n    e = (c, f3) => (f3 ? c : c.replace(/\\r?\\n|\\r/g, \"\\r\\n\")).replace(/\\n/g, \"%0A\").replace(/\\r/g, \"%0D\").replace(/\"/g, \"%22\");\n    x = (n, a, e2) => {\n      if (a.length < e2) {\n        throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e2} arguments required, but only ${a.length} present.`);\n      }\n    };\n    FormData = class FormData2 {\n      #d = [];\n      constructor(...a) {\n        if (a.length)\n          throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);\n      }\n      get [t]() {\n        return \"FormData\";\n      }\n      [i]() {\n        return this.entries();\n      }\n      static [h](o) {\n        return o && typeof o === \"object\" && o[t] === \"FormData\" && !m.some((m2) => typeof o[m2] != \"function\");\n      }\n      append(...a) {\n        x(\"append\", arguments, 2);\n        this.#d.push(f(...a));\n      }\n      delete(a) {\n        x(\"delete\", arguments, 1);\n        a += \"\";\n        this.#d = this.#d.filter(([b]) => b !== a);\n      }\n      get(a) {\n        x(\"get\", arguments, 1);\n        a += \"\";\n        for (var b = this.#d, l = b.length, c = 0; c < l; c++)\n          if (b[c][0] === a)\n            return b[c][1];\n        return null;\n      }\n      getAll(a, b) {\n        x(\"getAll\", arguments, 1);\n        b = [];\n        a += \"\";\n        this.#d.forEach((c) => c[0] === a && b.push(c[1]));\n        return b;\n      }\n      has(a) {\n        x(\"has\", arguments, 1);\n        a += \"\";\n        return this.#d.some((b) => b[0] === a);\n      }\n      forEach(a, b) {\n        x(\"forEach\", arguments, 1);\n        for (var [c, d] of this)\n          a.call(b, d, c, this);\n      }\n      set(...a) {\n        x(\"set\", arguments, 2);\n        var b = [], c = true;\n        a = f(...a);\n        this.#d.forEach((d) => {\n          d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);\n        });\n        c && b.push(a);\n        this.#d = b;\n      }\n      *entries() {\n        yield* this.#d;\n      }\n      *keys() {\n        for (var [a] of this)\n          yield a;\n      }\n      *values() {\n        for (var [, a] of this)\n          yield a;\n      }\n    };\n  }\n});\n\n// node_modules/fetch-blob/from.js\nvar import_node_fs, import_node_path, import_node_worker_threads, stat, DOMException2, BlobDataItem;\nvar init_from = __esm({\n  \"node_modules/fetch-blob/from.js\"() {\n    import_node_fs = __toModule(require(\"fs\"));\n    import_node_path = __toModule(require(\"path\"));\n    import_node_worker_threads = __toModule(require(\"worker_threads\"));\n    init_file();\n    init_fetch_blob();\n    ({ stat } = import_node_fs.promises);\n    DOMException2 = globalThis.DOMException || (() => {\n      const port = new import_node_worker_threads.MessageChannel().port1;\n      const ab = new ArrayBuffer(0);\n      try {\n        port.postMessage(ab, [ab, ab]);\n      } catch (err) {\n        return err.constructor;\n      }\n    })();\n    BlobDataItem = class {\n      #path;\n      #start;\n      constructor(options) {\n        this.#path = options.path;\n        this.#start = options.start;\n        this.size = options.size;\n        this.lastModified = options.lastModified;\n      }\n      slice(start, end) {\n        return new BlobDataItem({\n          path: this.#path,\n          lastModified: this.lastModified,\n          size: end - start,\n          start\n        });\n      }\n      async *stream() {\n        const { mtimeMs } = await stat(this.#path);\n        if (mtimeMs > this.lastModified) {\n          throw new DOMException2(\"The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.\", \"NotReadableError\");\n        }\n        yield* (0, import_node_fs.createReadStream)(this.#path, {\n          start: this.#start,\n          end: this.#start + this.size - 1\n        });\n      }\n      get [Symbol.toStringTag]() {\n        return \"Blob\";\n      }\n    };\n  }\n});\n\n// node_modules/node-fetch/src/utils/multipart-parser.js\nvar multipart_parser_exports = {};\n__export(multipart_parser_exports, {\n  toFormData: () => toFormData\n});\nfunction _fileName(headerValue) {\n  const m2 = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n  if (!m2) {\n    return;\n  }\n  const match = m2[2] || m2[3] || \"\";\n  let filename = match.slice(match.lastIndexOf(\"\\\\\") + 1);\n  filename = filename.replace(/%22/g, '\"');\n  filename = filename.replace(/&#(\\d{4});/g, (m3, code) => {\n    return String.fromCharCode(code);\n  });\n  return filename;\n}\nasync function toFormData(Body2, ct) {\n  if (!/multipart/i.test(ct)) {\n    throw new TypeError(\"Failed to fetch\");\n  }\n  const m2 = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n  if (!m2) {\n    throw new TypeError(\"no or bad content-type header, no multipart boundary\");\n  }\n  const parser = new MultipartParser(m2[1] || m2[2]);\n  let headerField;\n  let headerValue;\n  let entryValue;\n  let entryName;\n  let contentType;\n  let filename;\n  const entryChunks = [];\n  const formData = new FormData();\n  const onPartData = (ui8a) => {\n    entryValue += decoder.decode(ui8a, { stream: true });\n  };\n  const appendToFile = (ui8a) => {\n    entryChunks.push(ui8a);\n  };\n  const appendFileToFormData = () => {\n    const file = new file_default(entryChunks, filename, { type: contentType });\n    formData.append(entryName, file);\n  };\n  const appendEntryToFormData = () => {\n    formData.append(entryName, entryValue);\n  };\n  const decoder = new TextDecoder(\"utf-8\");\n  decoder.decode();\n  parser.onPartBegin = function() {\n    parser.onPartData = onPartData;\n    parser.onPartEnd = appendEntryToFormData;\n    headerField = \"\";\n    headerValue = \"\";\n    entryValue = \"\";\n    entryName = \"\";\n    contentType = \"\";\n    filename = null;\n    entryChunks.length = 0;\n  };\n  parser.onHeaderField = function(ui8a) {\n    headerField += decoder.decode(ui8a, { stream: true });\n  };\n  parser.onHeaderValue = function(ui8a) {\n    headerValue += decoder.decode(ui8a, { stream: true });\n  };\n  parser.onHeaderEnd = function() {\n    headerValue += decoder.decode();\n    headerField = headerField.toLowerCase();\n    if (headerField === \"content-disposition\") {\n      const m3 = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n      if (m3) {\n        entryName = m3[2] || m3[3] || \"\";\n      }\n      filename = _fileName(headerValue);\n      if (filename) {\n        parser.onPartData = appendToFile;\n        parser.onPartEnd = appendFileToFormData;\n      }\n    } else if (headerField === \"content-type\") {\n      contentType = headerValue;\n    }\n    headerValue = \"\";\n    headerField = \"\";\n  };\n  for await (const chunk of Body2) {\n    parser.write(chunk);\n  }\n  parser.end();\n  return formData;\n}\nvar s, S, f2, F, LF, CR, SPACE, HYPHEN, COLON, A, Z, lower, noop, MultipartParser;\nvar init_multipart_parser = __esm({\n  \"node_modules/node-fetch/src/utils/multipart-parser.js\"() {\n    init_from();\n    init_esm_min();\n    s = 0;\n    S = {\n      START_BOUNDARY: s++,\n      HEADER_FIELD_START: s++,\n      HEADER_FIELD: s++,\n      HEADER_VALUE_START: s++,\n      HEADER_VALUE: s++,\n      HEADER_VALUE_ALMOST_DONE: s++,\n      HEADERS_ALMOST_DONE: s++,\n      PART_DATA_START: s++,\n      PART_DATA: s++,\n      END: s++\n    };\n    f2 = 1;\n    F = {\n      PART_BOUNDARY: f2,\n      LAST_BOUNDARY: f2 *= 2\n    };\n    LF = 10;\n    CR = 13;\n    SPACE = 32;\n    HYPHEN = 45;\n    COLON = 58;\n    A = 97;\n    Z = 122;\n    lower = (c) => c | 32;\n    noop = () => {\n    };\n    MultipartParser = class {\n      constructor(boundary) {\n        this.index = 0;\n        this.flags = 0;\n        this.onHeaderEnd = noop;\n        this.onHeaderField = noop;\n        this.onHeadersEnd = noop;\n        this.onHeaderValue = noop;\n        this.onPartBegin = noop;\n        this.onPartData = noop;\n        this.onPartEnd = noop;\n        this.boundaryChars = {};\n        boundary = \"\\r\\n--\" + boundary;\n        const ui8a = new Uint8Array(boundary.length);\n        for (let i2 = 0; i2 < boundary.length; i2++) {\n          ui8a[i2] = boundary.charCodeAt(i2);\n          this.boundaryChars[ui8a[i2]] = true;\n        }\n        this.boundary = ui8a;\n        this.lookbehind = new Uint8Array(this.boundary.length + 8);\n        this.state = S.START_BOUNDARY;\n      }\n      write(data) {\n        let i2 = 0;\n        const length_ = data.length;\n        let previousIndex = this.index;\n        let { lookbehind, boundary, boundaryChars, index, state, flags } = this;\n        const boundaryLength = this.boundary.length;\n        const boundaryEnd = boundaryLength - 1;\n        const bufferLength = data.length;\n        let c;\n        let cl;\n        const mark = (name) => {\n          this[name + \"Mark\"] = i2;\n        };\n        const clear = (name) => {\n          delete this[name + \"Mark\"];\n        };\n        const callback = (callbackSymbol, start, end, ui8a) => {\n          if (start === void 0 || start !== end) {\n            this[callbackSymbol](ui8a && ui8a.subarray(start, end));\n          }\n        };\n        const dataCallback = (name, clear2) => {\n          const markSymbol = name + \"Mark\";\n          if (!(markSymbol in this)) {\n            return;\n          }\n          if (clear2) {\n            callback(name, this[markSymbol], i2, data);\n            delete this[markSymbol];\n          } else {\n            callback(name, this[markSymbol], data.length, data);\n            this[markSymbol] = 0;\n          }\n        };\n        for (i2 = 0; i2 < length_; i2++) {\n          c = data[i2];\n          switch (state) {\n            case S.START_BOUNDARY:\n              if (index === boundary.length - 2) {\n                if (c === HYPHEN) {\n                  flags |= F.LAST_BOUNDARY;\n                } else if (c !== CR) {\n                  return;\n                }\n                index++;\n                break;\n              } else if (index - 1 === boundary.length - 2) {\n                if (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n                  state = S.END;\n                  flags = 0;\n                } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n                  index = 0;\n                  callback(\"onPartBegin\");\n                  state = S.HEADER_FIELD_START;\n                } else {\n                  return;\n                }\n                break;\n              }\n              if (c !== boundary[index + 2]) {\n                index = -2;\n              }\n              if (c === boundary[index + 2]) {\n                index++;\n              }\n              break;\n            case S.HEADER_FIELD_START:\n              state = S.HEADER_FIELD;\n              mark(\"onHeaderField\");\n              index = 0;\n            case S.HEADER_FIELD:\n              if (c === CR) {\n                clear(\"onHeaderField\");\n                state = S.HEADERS_ALMOST_DONE;\n                break;\n              }\n              index++;\n              if (c === HYPHEN) {\n                break;\n              }\n              if (c === COLON) {\n                if (index === 1) {\n                  return;\n                }\n                dataCallback(\"onHeaderField\", true);\n                state = S.HEADER_VALUE_START;\n                break;\n              }\n              cl = lower(c);\n              if (cl < A || cl > Z) {\n                return;\n              }\n              break;\n            case S.HEADER_VALUE_START:\n              if (c === SPACE) {\n                break;\n              }\n              mark(\"onHeaderValue\");\n              state = S.HEADER_VALUE;\n            case S.HEADER_VALUE:\n              if (c === CR) {\n                dataCallback(\"onHeaderValue\", true);\n                callback(\"onHeaderEnd\");\n                state = S.HEADER_VALUE_ALMOST_DONE;\n              }\n              break;\n            case S.HEADER_VALUE_ALMOST_DONE:\n              if (c !== LF) {\n                return;\n              }\n              state = S.HEADER_FIELD_START;\n              break;\n            case S.HEADERS_ALMOST_DONE:\n              if (c !== LF) {\n                return;\n              }\n              callback(\"onHeadersEnd\");\n              state = S.PART_DATA_START;\n              break;\n            case S.PART_DATA_START:\n              state = S.PART_DATA;\n              mark(\"onPartData\");\n            case S.PART_DATA:\n              previousIndex = index;\n              if (index === 0) {\n                i2 += boundaryEnd;\n                while (i2 < bufferLength && !(data[i2] in boundaryChars)) {\n                  i2 += boundaryLength;\n                }\n                i2 -= boundaryEnd;\n                c = data[i2];\n              }\n              if (index < boundary.length) {\n                if (boundary[index] === c) {\n                  if (index === 0) {\n                    dataCallback(\"onPartData\", true);\n                  }\n                  index++;\n                } else {\n                  index = 0;\n                }\n              } else if (index === boundary.length) {\n                index++;\n                if (c === CR) {\n                  flags |= F.PART_BOUNDARY;\n                } else if (c === HYPHEN) {\n                  flags |= F.LAST_BOUNDARY;\n                } else {\n                  index = 0;\n                }\n              } else if (index - 1 === boundary.length) {\n                if (flags & F.PART_BOUNDARY) {\n                  index = 0;\n                  if (c === LF) {\n                    flags &= ~F.PART_BOUNDARY;\n                    callback(\"onPartEnd\");\n                    callback(\"onPartBegin\");\n                    state = S.HEADER_FIELD_START;\n                    break;\n                  }\n                } else if (flags & F.LAST_BOUNDARY) {\n                  if (c === HYPHEN) {\n                    callback(\"onPartEnd\");\n                    state = S.END;\n                    flags = 0;\n                  } else {\n                    index = 0;\n                  }\n                } else {\n                  index = 0;\n                }\n              }\n              if (index > 0) {\n                lookbehind[index - 1] = c;\n              } else if (previousIndex > 0) {\n                const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n                callback(\"onPartData\", 0, previousIndex, _lookbehind);\n                previousIndex = 0;\n                mark(\"onPartData\");\n                i2--;\n              }\n              break;\n            case S.END:\n              break;\n            default:\n              throw new Error(`Unexpected state entered: ${state}`);\n          }\n        }\n        dataCallback(\"onHeaderField\");\n        dataCallback(\"onHeaderValue\");\n        dataCallback(\"onPartData\");\n        this.index = index;\n        this.state = state;\n        this.flags = flags;\n      }\n      end() {\n        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {\n          this.onPartEnd();\n        } else if (this.state !== S.END) {\n          throw new Error(\"MultipartParser.end(): stream ended unexpectedly\");\n        }\n      }\n    };\n  }\n});\n\n// src/index.js\n__export(exports, {\n  AbortError: () => AbortError,\n  Blob: () => Blob2,\n  FetchError: () => FetchError,\n  FormData: () => FormData,\n  Headers: () => Headers,\n  Request: () => Request,\n  Response: () => Response,\n  default: () => fetch,\n  isRedirect: () => isRedirect\n});\n\n// node_modules/node-fetch/src/index.js\nvar import_node_http2 = __toModule(require(\"http\"));\nvar import_node_https = __toModule(require(\"https\"));\nvar import_node_zlib = __toModule(require(\"zlib\"));\nvar import_node_stream2 = __toModule(require(\"stream\"));\n\n// node_modules/data-uri-to-buffer/dist/index.js\nfunction dataUriToBuffer(uri) {\n  if (!/^data:/i.test(uri)) {\n    throw new TypeError('`uri` does not appear to be a Data URI (must begin with \"data:\")');\n  }\n  uri = uri.replace(/\\r?\\n/g, \"\");\n  const firstComma = uri.indexOf(\",\");\n  if (firstComma === -1 || firstComma <= 4) {\n    throw new TypeError(\"malformed data: URI\");\n  }\n  const meta = uri.substring(5, firstComma).split(\";\");\n  let charset = \"\";\n  let base64 = false;\n  const type = meta[0] || \"text/plain\";\n  let typeFull = type;\n  for (let i2 = 1; i2 < meta.length; i2++) {\n    if (meta[i2] === \"base64\") {\n      base64 = true;\n    } else {\n      typeFull += `;${meta[i2]}`;\n      if (meta[i2].indexOf(\"charset=\") === 0) {\n        charset = meta[i2].substring(8);\n      }\n    }\n  }\n  if (!meta[0] && !charset.length) {\n    typeFull += \";charset=US-ASCII\";\n    charset = \"US-ASCII\";\n  }\n  const encoding = base64 ? \"base64\" : \"ascii\";\n  const data = unescape(uri.substring(firstComma + 1));\n  const buffer = Buffer.from(data, encoding);\n  buffer.type = type;\n  buffer.typeFull = typeFull;\n  buffer.charset = charset;\n  return buffer;\n}\nvar dist_default = dataUriToBuffer;\n\n// node_modules/node-fetch/src/body.js\nvar import_node_stream = __toModule(require(\"stream\"));\nvar import_node_util = __toModule(require(\"util\"));\ninit_fetch_blob();\ninit_esm_min();\n\n// node_modules/node-fetch/src/errors/base.js\nvar FetchBaseError = class extends Error {\n  constructor(message, type) {\n    super(message);\n    Error.captureStackTrace(this, this.constructor);\n    this.type = type;\n  }\n  get name() {\n    return this.constructor.name;\n  }\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n};\n\n// node_modules/node-fetch/src/errors/fetch-error.js\nvar FetchError = class extends FetchBaseError {\n  constructor(message, type, systemError) {\n    super(message, type);\n    if (systemError) {\n      this.code = this.errno = systemError.code;\n      this.erroredSysCall = systemError.syscall;\n    }\n  }\n};\n\n// node_modules/node-fetch/src/utils/is.js\nvar NAME = Symbol.toStringTag;\nvar isURLSearchParameters = (object) => {\n  return typeof object === \"object\" && typeof object.append === \"function\" && typeof object.delete === \"function\" && typeof object.get === \"function\" && typeof object.getAll === \"function\" && typeof object.has === \"function\" && typeof object.set === \"function\" && typeof object.sort === \"function\" && object[NAME] === \"URLSearchParams\";\n};\nvar isBlob = (object) => {\n  return object && typeof object === \"object\" && typeof object.arrayBuffer === \"function\" && typeof object.type === \"string\" && typeof object.stream === \"function\" && typeof object.constructor === \"function\" && /^(Blob|File)$/.test(object[NAME]);\n};\nvar isAbortSignal = (object) => {\n  return typeof object === \"object\" && (object[NAME] === \"AbortSignal\" || object[NAME] === \"EventTarget\");\n};\n\n// node_modules/node-fetch/src/body.js\nvar INTERNALS = Symbol(\"Body internals\");\nvar Body = class {\n  constructor(body, {\n    size = 0\n  } = {}) {\n    let boundary = null;\n    if (body === null) {\n      body = null;\n    } else if (isURLSearchParameters(body)) {\n      body = Buffer.from(body.toString());\n    } else if (isBlob(body)) {\n    } else if (Buffer.isBuffer(body)) {\n    } else if (import_node_util.types.isAnyArrayBuffer(body)) {\n      body = Buffer.from(body);\n    } else if (ArrayBuffer.isView(body)) {\n      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n    } else if (body instanceof import_node_stream.default) {\n    } else if (body instanceof FormData) {\n      body = formDataToBlob(body);\n      boundary = body.type.split(\"=\")[1];\n    } else {\n      body = Buffer.from(String(body));\n    }\n    let stream = body;\n    if (Buffer.isBuffer(body)) {\n      stream = import_node_stream.default.Readable.from(body);\n    } else if (isBlob(body)) {\n      stream = import_node_stream.default.Readable.from(body.stream());\n    }\n    this[INTERNALS] = {\n      body,\n      stream,\n      boundary,\n      disturbed: false,\n      error: null\n    };\n    this.size = size;\n    if (body instanceof import_node_stream.default) {\n      body.on(\"error\", (error_) => {\n        const error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, \"system\", error_);\n        this[INTERNALS].error = error;\n      });\n    }\n  }\n  get body() {\n    return this[INTERNALS].stream;\n  }\n  get bodyUsed() {\n    return this[INTERNALS].disturbed;\n  }\n  async arrayBuffer() {\n    const { buffer, byteOffset, byteLength } = await consumeBody(this);\n    return buffer.slice(byteOffset, byteOffset + byteLength);\n  }\n  async formData() {\n    const ct = this.headers.get(\"content-type\");\n    if (ct.startsWith(\"application/x-www-form-urlencoded\")) {\n      const formData = new FormData();\n      const parameters = new URLSearchParams(await this.text());\n      for (const [name, value] of parameters) {\n        formData.append(name, value);\n      }\n      return formData;\n    }\n    const { toFormData: toFormData2 } = await Promise.resolve().then(() => (init_multipart_parser(), multipart_parser_exports));\n    return toFormData2(this.body, ct);\n  }\n  async blob() {\n    const ct = this.headers && this.headers.get(\"content-type\") || this[INTERNALS].body && this[INTERNALS].body.type || \"\";\n    const buf = await this.buffer();\n    return new fetch_blob_default([buf], {\n      type: ct\n    });\n  }\n  async json() {\n    const buffer = await consumeBody(this);\n    return JSON.parse(buffer.toString());\n  }\n  async text() {\n    const buffer = await consumeBody(this);\n    return buffer.toString();\n  }\n  buffer() {\n    return consumeBody(this);\n  }\n};\nBody.prototype.buffer = (0, import_node_util.deprecate)(Body.prototype.buffer, \"Please use 'response.arrayBuffer()' instead of 'response.buffer()'\", \"node-fetch#buffer\");\nObject.defineProperties(Body.prototype, {\n  body: { enumerable: true },\n  bodyUsed: { enumerable: true },\n  arrayBuffer: { enumerable: true },\n  blob: { enumerable: true },\n  json: { enumerable: true },\n  text: { enumerable: true }\n});\nasync function consumeBody(data) {\n  if (data[INTERNALS].disturbed) {\n    throw new TypeError(`body used already for: ${data.url}`);\n  }\n  data[INTERNALS].disturbed = true;\n  if (data[INTERNALS].error) {\n    throw data[INTERNALS].error;\n  }\n  const { body } = data;\n  if (body === null) {\n    return Buffer.alloc(0);\n  }\n  if (!(body instanceof import_node_stream.default)) {\n    return Buffer.alloc(0);\n  }\n  const accum = [];\n  let accumBytes = 0;\n  try {\n    for await (const chunk of body) {\n      if (data.size > 0 && accumBytes + chunk.length > data.size) {\n        const error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, \"max-size\");\n        body.destroy(error);\n        throw error;\n      }\n      accumBytes += chunk.length;\n      accum.push(chunk);\n    }\n  } catch (error) {\n    const error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, \"system\", error);\n    throw error_;\n  }\n  if (body.readableEnded === true || body._readableState.ended === true) {\n    try {\n      if (accum.every((c) => typeof c === \"string\")) {\n        return Buffer.from(accum.join(\"\"));\n      }\n      return Buffer.concat(accum, accumBytes);\n    } catch (error) {\n      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, \"system\", error);\n    }\n  } else {\n    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);\n  }\n}\nvar clone = (instance, highWaterMark) => {\n  let p1;\n  let p2;\n  let { body } = instance[INTERNALS];\n  if (instance.bodyUsed) {\n    throw new Error(\"cannot clone body after it is used\");\n  }\n  if (body instanceof import_node_stream.default && typeof body.getBoundary !== \"function\") {\n    p1 = new import_node_stream.PassThrough({ highWaterMark });\n    p2 = new import_node_stream.PassThrough({ highWaterMark });\n    body.pipe(p1);\n    body.pipe(p2);\n    instance[INTERNALS].stream = p1;\n    body = p2;\n  }\n  return body;\n};\nvar getNonSpecFormDataBoundary = (0, import_node_util.deprecate)((body) => body.getBoundary(), \"form-data doesn't follow the spec and requires special treatment. Use alternative package\", \"https://github.com/node-fetch/node-fetch/issues/1167\");\nvar extractContentType = (body, request) => {\n  if (body === null) {\n    return null;\n  }\n  if (typeof body === \"string\") {\n    return \"text/plain;charset=UTF-8\";\n  }\n  if (isURLSearchParameters(body)) {\n    return \"application/x-www-form-urlencoded;charset=UTF-8\";\n  }\n  if (isBlob(body)) {\n    return body.type || null;\n  }\n  if (Buffer.isBuffer(body) || import_node_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {\n    return null;\n  }\n  if (body instanceof FormData) {\n    return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;\n  }\n  if (body && typeof body.getBoundary === \"function\") {\n    return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;\n  }\n  if (body instanceof import_node_stream.default) {\n    return null;\n  }\n  return \"text/plain;charset=UTF-8\";\n};\nvar getTotalBytes = (request) => {\n  const { body } = request[INTERNALS];\n  if (body === null) {\n    return 0;\n  }\n  if (isBlob(body)) {\n    return body.size;\n  }\n  if (Buffer.isBuffer(body)) {\n    return body.length;\n  }\n  if (body && typeof body.getLengthSync === \"function\") {\n    return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;\n  }\n  return null;\n};\nvar writeToStream = (dest, { body }) => {\n  if (body === null) {\n    dest.end();\n  } else {\n    body.pipe(dest);\n  }\n};\n\n// node_modules/node-fetch/src/headers.js\nvar import_node_util2 = __toModule(require(\"util\"));\nvar import_node_http = __toModule(require(\"http\"));\nvar validateHeaderName = typeof import_node_http.default.validateHeaderName === \"function\" ? import_node_http.default.validateHeaderName : (name) => {\n  if (!/^[\\^`\\-\\w!#$%&'*+.|~]+$/.test(name)) {\n    const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);\n    Object.defineProperty(error, \"code\", { value: \"ERR_INVALID_HTTP_TOKEN\" });\n    throw error;\n  }\n};\nvar validateHeaderValue = typeof import_node_http.default.validateHeaderValue === \"function\" ? import_node_http.default.validateHeaderValue : (name, value) => {\n  if (/[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/.test(value)) {\n    const error = new TypeError(`Invalid character in header content [\"${name}\"]`);\n    Object.defineProperty(error, \"code\", { value: \"ERR_INVALID_CHAR\" });\n    throw error;\n  }\n};\nvar Headers = class extends URLSearchParams {\n  constructor(init) {\n    let result = [];\n    if (init instanceof Headers) {\n      const raw = init.raw();\n      for (const [name, values] of Object.entries(raw)) {\n        result.push(...values.map((value) => [name, value]));\n      }\n    } else if (init == null) {\n    } else if (typeof init === \"object\" && !import_node_util2.types.isBoxedPrimitive(init)) {\n      const method = init[Symbol.iterator];\n      if (method == null) {\n        result.push(...Object.entries(init));\n      } else {\n        if (typeof method !== \"function\") {\n          throw new TypeError(\"Header pairs must be iterable\");\n        }\n        result = [...init].map((pair) => {\n          if (typeof pair !== \"object\" || import_node_util2.types.isBoxedPrimitive(pair)) {\n            throw new TypeError(\"Each header pair must be an iterable object\");\n          }\n          return [...pair];\n        }).map((pair) => {\n          if (pair.length !== 2) {\n            throw new TypeError(\"Each header pair must be a name/value tuple\");\n          }\n          return [...pair];\n        });\n      }\n    } else {\n      throw new TypeError(\"Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)\");\n    }\n    result = result.length > 0 ? result.map(([name, value]) => {\n      validateHeaderName(name);\n      validateHeaderValue(name, String(value));\n      return [String(name).toLowerCase(), String(value)];\n    }) : void 0;\n    super(result);\n    return new Proxy(this, {\n      get(target, p, receiver) {\n        switch (p) {\n          case \"append\":\n          case \"set\":\n            return (name, value) => {\n              validateHeaderName(name);\n              validateHeaderValue(name, String(value));\n              return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value));\n            };\n          case \"delete\":\n          case \"has\":\n          case \"getAll\":\n            return (name) => {\n              validateHeaderName(name);\n              return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());\n            };\n          case \"keys\":\n            return () => {\n              target.sort();\n              return new Set(URLSearchParams.prototype.keys.call(target)).keys();\n            };\n          default:\n            return Reflect.get(target, p, receiver);\n        }\n      }\n    });\n  }\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n  toString() {\n    return Object.prototype.toString.call(this);\n  }\n  get(name) {\n    const values = this.getAll(name);\n    if (values.length === 0) {\n      return null;\n    }\n    let value = values.join(\", \");\n    if (/^content-encoding$/i.test(name)) {\n      value = value.toLowerCase();\n    }\n    return value;\n  }\n  forEach(callback, thisArg = void 0) {\n    for (const name of this.keys()) {\n      Reflect.apply(callback, thisArg, [this.get(name), name, this]);\n    }\n  }\n  *values() {\n    for (const name of this.keys()) {\n      yield this.get(name);\n    }\n  }\n  *entries() {\n    for (const name of this.keys()) {\n      yield [name, this.get(name)];\n    }\n  }\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  raw() {\n    return [...this.keys()].reduce((result, key) => {\n      result[key] = this.getAll(key);\n      return result;\n    }, {});\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return [...this.keys()].reduce((result, key) => {\n      const values = this.getAll(key);\n      if (key === \"host\") {\n        result[key] = values[0];\n      } else {\n        result[key] = values.length > 1 ? values : values[0];\n      }\n      return result;\n    }, {});\n  }\n};\nObject.defineProperties(Headers.prototype, [\"get\", \"entries\", \"forEach\", \"values\"].reduce((result, property) => {\n  result[property] = { enumerable: true };\n  return result;\n}, {}));\nfunction fromRawHeaders(headers = []) {\n  return new Headers(headers.reduce((result, value, index, array) => {\n    if (index % 2 === 0) {\n      result.push(array.slice(index, index + 2));\n    }\n    return result;\n  }, []).filter(([name, value]) => {\n    try {\n      validateHeaderName(name);\n      validateHeaderValue(name, String(value));\n      return true;\n    } catch {\n      return false;\n    }\n  }));\n}\n\n// node_modules/node-fetch/src/utils/is-redirect.js\nvar redirectStatus = new Set([301, 302, 303, 307, 308]);\nvar isRedirect = (code) => {\n  return redirectStatus.has(code);\n};\n\n// node_modules/node-fetch/src/response.js\nvar INTERNALS2 = Symbol(\"Response internals\");\nvar Response = class extends Body {\n  constructor(body = null, options = {}) {\n    super(body, options);\n    const status = options.status != null ? options.status : 200;\n    const headers = new Headers(options.headers);\n    if (body !== null && !headers.has(\"Content-Type\")) {\n      const contentType = extractContentType(body, this);\n      if (contentType) {\n        headers.append(\"Content-Type\", contentType);\n      }\n    }\n    this[INTERNALS2] = {\n      type: \"default\",\n      url: options.url,\n      status,\n      statusText: options.statusText || \"\",\n      headers,\n      counter: options.counter,\n      highWaterMark: options.highWaterMark\n    };\n  }\n  get type() {\n    return this[INTERNALS2].type;\n  }\n  get url() {\n    return this[INTERNALS2].url || \"\";\n  }\n  get status() {\n    return this[INTERNALS2].status;\n  }\n  get ok() {\n    return this[INTERNALS2].status >= 200 && this[INTERNALS2].status < 300;\n  }\n  get redirected() {\n    return this[INTERNALS2].counter > 0;\n  }\n  get statusText() {\n    return this[INTERNALS2].statusText;\n  }\n  get headers() {\n    return this[INTERNALS2].headers;\n  }\n  get highWaterMark() {\n    return this[INTERNALS2].highWaterMark;\n  }\n  clone() {\n    return new Response(clone(this, this.highWaterMark), {\n      type: this.type,\n      url: this.url,\n      status: this.status,\n      statusText: this.statusText,\n      headers: this.headers,\n      ok: this.ok,\n      redirected: this.redirected,\n      size: this.size,\n      highWaterMark: this.highWaterMark\n    });\n  }\n  static redirect(url, status = 302) {\n    if (!isRedirect(status)) {\n      throw new RangeError('Failed to execute \"redirect\" on \"response\": Invalid status code');\n    }\n    return new Response(null, {\n      headers: {\n        location: new URL(url).toString()\n      },\n      status\n    });\n  }\n  static error() {\n    const response = new Response(null, { status: 0, statusText: \"\" });\n    response[INTERNALS2].type = \"error\";\n    return response;\n  }\n  get [Symbol.toStringTag]() {\n    return \"Response\";\n  }\n};\nObject.defineProperties(Response.prototype, {\n  type: { enumerable: true },\n  url: { enumerable: true },\n  status: { enumerable: true },\n  ok: { enumerable: true },\n  redirected: { enumerable: true },\n  statusText: { enumerable: true },\n  headers: { enumerable: true },\n  clone: { enumerable: true }\n});\n\n// node_modules/node-fetch/src/request.js\nvar import_node_url = __toModule(require(\"url\"));\n\n// node_modules/node-fetch/src/utils/get-search.js\nvar getSearch = (parsedURL) => {\n  if (parsedURL.search) {\n    return parsedURL.search;\n  }\n  const lastOffset = parsedURL.href.length - 1;\n  const hash = parsedURL.hash || (parsedURL.href[lastOffset] === \"#\" ? \"#\" : \"\");\n  return parsedURL.href[lastOffset - hash.length] === \"?\" ? \"?\" : \"\";\n};\n\n// node_modules/node-fetch/src/utils/referrer.js\nvar import_net = __toModule(require(\"net\"));\nfunction stripURLForUseAsAReferrer(url, originOnly = false) {\n  if (url == null) {\n    return \"no-referrer\";\n  }\n  url = new URL(url);\n  if (/^(about|blob|data):$/.test(url.protocol)) {\n    return \"no-referrer\";\n  }\n  url.username = \"\";\n  url.password = \"\";\n  url.hash = \"\";\n  if (originOnly) {\n    url.pathname = \"\";\n    url.search = \"\";\n  }\n  return url;\n}\nvar ReferrerPolicy = new Set([\n  \"\",\n  \"no-referrer\",\n  \"no-referrer-when-downgrade\",\n  \"same-origin\",\n  \"origin\",\n  \"strict-origin\",\n  \"origin-when-cross-origin\",\n  \"strict-origin-when-cross-origin\",\n  \"unsafe-url\"\n]);\nvar DEFAULT_REFERRER_POLICY = \"strict-origin-when-cross-origin\";\nfunction validateReferrerPolicy(referrerPolicy) {\n  if (!ReferrerPolicy.has(referrerPolicy)) {\n    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);\n  }\n  return referrerPolicy;\n}\nfunction isOriginPotentiallyTrustworthy(url) {\n  if (/^(http|ws)s:$/.test(url.protocol)) {\n    return true;\n  }\n  const hostIp = url.host.replace(/(^\\[)|(]$)/g, \"\");\n  const hostIPVersion = (0, import_net.isIP)(hostIp);\n  if (hostIPVersion === 4 && /^127\\./.test(hostIp)) {\n    return true;\n  }\n  if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {\n    return true;\n  }\n  if (/^(.+\\.)*localhost$/.test(url.host)) {\n    return false;\n  }\n  if (url.protocol === \"file:\") {\n    return true;\n  }\n  return false;\n}\nfunction isUrlPotentiallyTrustworthy(url) {\n  if (/^about:(blank|srcdoc)$/.test(url)) {\n    return true;\n  }\n  if (url.protocol === \"data:\") {\n    return true;\n  }\n  if (/^(blob|filesystem):$/.test(url.protocol)) {\n    return true;\n  }\n  return isOriginPotentiallyTrustworthy(url);\n}\nfunction determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {\n  if (request.referrer === \"no-referrer\" || request.referrerPolicy === \"\") {\n    return null;\n  }\n  const policy = request.referrerPolicy;\n  if (request.referrer === \"about:client\") {\n    return \"no-referrer\";\n  }\n  const referrerSource = request.referrer;\n  let referrerURL = stripURLForUseAsAReferrer(referrerSource);\n  let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);\n  if (referrerURL.toString().length > 4096) {\n    referrerURL = referrerOrigin;\n  }\n  if (referrerURLCallback) {\n    referrerURL = referrerURLCallback(referrerURL);\n  }\n  if (referrerOriginCallback) {\n    referrerOrigin = referrerOriginCallback(referrerOrigin);\n  }\n  const currentURL = new URL(request.url);\n  switch (policy) {\n    case \"no-referrer\":\n      return \"no-referrer\";\n    case \"origin\":\n      return referrerOrigin;\n    case \"unsafe-url\":\n      return referrerURL;\n    case \"strict-origin\":\n      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n        return \"no-referrer\";\n      }\n      return referrerOrigin.toString();\n    case \"strict-origin-when-cross-origin\":\n      if (referrerURL.origin === currentURL.origin) {\n        return referrerURL;\n      }\n      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n        return \"no-referrer\";\n      }\n      return referrerOrigin;\n    case \"same-origin\":\n      if (referrerURL.origin === currentURL.origin) {\n        return referrerURL;\n      }\n      return \"no-referrer\";\n    case \"origin-when-cross-origin\":\n      if (referrerURL.origin === currentURL.origin) {\n        return referrerURL;\n      }\n      return referrerOrigin;\n    case \"no-referrer-when-downgrade\":\n      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n        return \"no-referrer\";\n      }\n      return referrerURL;\n    default:\n      throw new TypeError(`Invalid referrerPolicy: ${policy}`);\n  }\n}\nfunction parseReferrerPolicyFromHeader(headers) {\n  const policyTokens = (headers.get(\"referrer-policy\") || \"\").split(/[,\\s]+/);\n  let policy = \"\";\n  for (const token of policyTokens) {\n    if (token && ReferrerPolicy.has(token)) {\n      policy = token;\n    }\n  }\n  return policy;\n}\n\n// node_modules/node-fetch/src/request.js\nvar INTERNALS3 = Symbol(\"Request internals\");\nvar isRequest = (object) => {\n  return typeof object === \"object\" && typeof object[INTERNALS3] === \"object\";\n};\nvar Request = class extends Body {\n  constructor(input, init = {}) {\n    let parsedURL;\n    if (isRequest(input)) {\n      parsedURL = new URL(input.url);\n    } else {\n      parsedURL = new URL(input);\n      input = {};\n    }\n    if (parsedURL.username !== \"\" || parsedURL.password !== \"\") {\n      throw new TypeError(`${parsedURL} is an url with embedded credentails.`);\n    }\n    let method = init.method || input.method || \"GET\";\n    method = method.toUpperCase();\n    if ((init.body != null || isRequest(input)) && input.body !== null && (method === \"GET\" || method === \"HEAD\")) {\n      throw new TypeError(\"Request with GET/HEAD method cannot have body\");\n    }\n    const inputBody = init.body ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n    super(inputBody, {\n      size: init.size || input.size || 0\n    });\n    const headers = new Headers(init.headers || input.headers || {});\n    if (inputBody !== null && !headers.has(\"Content-Type\")) {\n      const contentType = extractContentType(inputBody, this);\n      if (contentType) {\n        headers.set(\"Content-Type\", contentType);\n      }\n    }\n    let signal = isRequest(input) ? input.signal : null;\n    if (\"signal\" in init) {\n      signal = init.signal;\n    }\n    if (signal != null && !isAbortSignal(signal)) {\n      throw new TypeError(\"Expected signal to be an instanceof AbortSignal or EventTarget\");\n    }\n    let referrer = init.referrer == null ? input.referrer : init.referrer;\n    if (referrer === \"\") {\n      referrer = \"no-referrer\";\n    } else if (referrer) {\n      const parsedReferrer = new URL(referrer);\n      referrer = /^about:(\\/\\/)?client$/.test(parsedReferrer) ? \"client\" : parsedReferrer;\n    } else {\n      referrer = void 0;\n    }\n    this[INTERNALS3] = {\n      method,\n      redirect: init.redirect || input.redirect || \"follow\",\n      headers,\n      parsedURL,\n      signal,\n      referrer\n    };\n    this.follow = init.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init.follow;\n    this.compress = init.compress === void 0 ? input.compress === void 0 ? true : input.compress : init.compress;\n    this.counter = init.counter || input.counter || 0;\n    this.agent = init.agent || input.agent;\n    this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;\n    this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;\n    this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || \"\";\n  }\n  get method() {\n    return this[INTERNALS3].method;\n  }\n  get url() {\n    return (0, import_node_url.format)(this[INTERNALS3].parsedURL);\n  }\n  get headers() {\n    return this[INTERNALS3].headers;\n  }\n  get redirect() {\n    return this[INTERNALS3].redirect;\n  }\n  get signal() {\n    return this[INTERNALS3].signal;\n  }\n  get referrer() {\n    if (this[INTERNALS3].referrer === \"no-referrer\") {\n      return \"\";\n    }\n    if (this[INTERNALS3].referrer === \"client\") {\n      return \"about:client\";\n    }\n    if (this[INTERNALS3].referrer) {\n      return this[INTERNALS3].referrer.toString();\n    }\n    return void 0;\n  }\n  get referrerPolicy() {\n    return this[INTERNALS3].referrerPolicy;\n  }\n  set referrerPolicy(referrerPolicy) {\n    this[INTERNALS3].referrerPolicy = validateReferrerPolicy(referrerPolicy);\n  }\n  clone() {\n    return new Request(this);\n  }\n  get [Symbol.toStringTag]() {\n    return \"Request\";\n  }\n};\nObject.defineProperties(Request.prototype, {\n  method: { enumerable: true },\n  url: { enumerable: true },\n  headers: { enumerable: true },\n  redirect: { enumerable: true },\n  clone: { enumerable: true },\n  signal: { enumerable: true },\n  referrer: { enumerable: true },\n  referrerPolicy: { enumerable: true }\n});\nvar getNodeRequestOptions = (request) => {\n  const { parsedURL } = request[INTERNALS3];\n  const headers = new Headers(request[INTERNALS3].headers);\n  if (!headers.has(\"Accept\")) {\n    headers.set(\"Accept\", \"*/*\");\n  }\n  let contentLengthValue = null;\n  if (request.body === null && /^(post|put)$/i.test(request.method)) {\n    contentLengthValue = \"0\";\n  }\n  if (request.body !== null) {\n    const totalBytes = getTotalBytes(request);\n    if (typeof totalBytes === \"number\" && !Number.isNaN(totalBytes)) {\n      contentLengthValue = String(totalBytes);\n    }\n  }\n  if (contentLengthValue) {\n    headers.set(\"Content-Length\", contentLengthValue);\n  }\n  if (request.referrerPolicy === \"\") {\n    request.referrerPolicy = DEFAULT_REFERRER_POLICY;\n  }\n  if (request.referrer && request.referrer !== \"no-referrer\") {\n    request[INTERNALS3].referrer = determineRequestsReferrer(request);\n  } else {\n    request[INTERNALS3].referrer = \"no-referrer\";\n  }\n  if (request[INTERNALS3].referrer instanceof URL) {\n    headers.set(\"Referer\", request.referrer);\n  }\n  if (!headers.has(\"User-Agent\")) {\n    headers.set(\"User-Agent\", \"node-fetch\");\n  }\n  if (request.compress && !headers.has(\"Accept-Encoding\")) {\n    headers.set(\"Accept-Encoding\", \"gzip,deflate,br\");\n  }\n  let { agent } = request;\n  if (typeof agent === \"function\") {\n    agent = agent(parsedURL);\n  }\n  if (!headers.has(\"Connection\") && !agent) {\n    headers.set(\"Connection\", \"close\");\n  }\n  const search = getSearch(parsedURL);\n  const options = {\n    path: parsedURL.pathname + search,\n    method: request.method,\n    headers: headers[Symbol.for(\"nodejs.util.inspect.custom\")](),\n    insecureHTTPParser: request.insecureHTTPParser,\n    agent\n  };\n  return {\n    parsedURL,\n    options\n  };\n};\n\n// node_modules/node-fetch/src/errors/abort-error.js\nvar AbortError = class extends FetchBaseError {\n  constructor(message, type = \"aborted\") {\n    super(message, type);\n  }\n};\n\n// node_modules/node-fetch/src/index.js\nvar supportedSchemas = new Set([\"data:\", \"http:\", \"https:\"]);\nasync function fetch(url, options_) {\n  return new Promise((resolve, reject) => {\n    const request = new Request(url, options_);\n    const { parsedURL, options } = getNodeRequestOptions(request);\n    if (!supportedSchemas.has(parsedURL.protocol)) {\n      throw new TypeError(`node-fetch cannot load ${url}. URL scheme \"${parsedURL.protocol.replace(/:$/, \"\")}\" is not supported.`);\n    }\n    if (parsedURL.protocol === \"data:\") {\n      const data = dist_default(request.url);\n      const response2 = new Response(data, { headers: { \"Content-Type\": data.typeFull } });\n      resolve(response2);\n      return;\n    }\n    const send = (parsedURL.protocol === \"https:\" ? import_node_https.default : import_node_http2.default).request;\n    const { signal } = request;\n    let response = null;\n    const abort = () => {\n      const error = new AbortError(\"The operation was aborted.\");\n      reject(error);\n      if (request.body && request.body instanceof import_node_stream2.default.Readable) {\n        request.body.destroy(error);\n      }\n      if (!response || !response.body) {\n        return;\n      }\n      response.body.emit(\"error\", error);\n    };\n    if (signal && signal.aborted) {\n      abort();\n      return;\n    }\n    const abortAndFinalize = () => {\n      abort();\n      finalize();\n    };\n    const request_ = send(parsedURL, options);\n    if (signal) {\n      signal.addEventListener(\"abort\", abortAndFinalize);\n    }\n    const finalize = () => {\n      request_.abort();\n      if (signal) {\n        signal.removeEventListener(\"abort\", abortAndFinalize);\n      }\n    };\n    request_.on(\"error\", (error) => {\n      reject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, \"system\", error));\n      finalize();\n    });\n    fixResponseChunkedTransferBadEnding(request_, (error) => {\n      response.body.destroy(error);\n    });\n    if (process.version < \"v14\") {\n      request_.on(\"socket\", (s2) => {\n        let endedWithEventsCount;\n        s2.prependListener(\"end\", () => {\n          endedWithEventsCount = s2._eventsCount;\n        });\n        s2.prependListener(\"close\", (hadError) => {\n          if (response && endedWithEventsCount < s2._eventsCount && !hadError) {\n            const error = new Error(\"Premature close\");\n            error.code = \"ERR_STREAM_PREMATURE_CLOSE\";\n            response.body.emit(\"error\", error);\n          }\n        });\n      });\n    }\n    request_.on(\"response\", (response_) => {\n      request_.setTimeout(0);\n      const headers = fromRawHeaders(response_.rawHeaders);\n      if (isRedirect(response_.statusCode)) {\n        const location = headers.get(\"Location\");\n        const locationURL = location === null ? null : new URL(location, request.url);\n        switch (request.redirect) {\n          case \"error\":\n            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, \"no-redirect\"));\n            finalize();\n            return;\n          case \"manual\":\n            if (locationURL !== null) {\n              headers.set(\"Location\", locationURL);\n            }\n            break;\n          case \"follow\": {\n            if (locationURL === null) {\n              break;\n            }\n            if (request.counter >= request.follow) {\n              reject(new FetchError(`maximum redirect reached at: ${request.url}`, \"max-redirect\"));\n              finalize();\n              return;\n            }\n            const requestOptions = {\n              headers: new Headers(request.headers),\n              follow: request.follow,\n              counter: request.counter + 1,\n              agent: request.agent,\n              compress: request.compress,\n              method: request.method,\n              body: clone(request),\n              signal: request.signal,\n              size: request.size,\n              referrer: request.referrer,\n              referrerPolicy: request.referrerPolicy\n            };\n            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_node_stream2.default.Readable) {\n              reject(new FetchError(\"Cannot follow redirect with body being a readable stream\", \"unsupported-redirect\"));\n              finalize();\n              return;\n            }\n            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === \"POST\") {\n              requestOptions.method = \"GET\";\n              requestOptions.body = void 0;\n              requestOptions.headers.delete(\"content-length\");\n            }\n            const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);\n            if (responseReferrerPolicy) {\n              requestOptions.referrerPolicy = responseReferrerPolicy;\n            }\n            resolve(fetch(new Request(locationURL, requestOptions)));\n            finalize();\n            return;\n          }\n          default:\n            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));\n        }\n      }\n      if (signal) {\n        response_.once(\"end\", () => {\n          signal.removeEventListener(\"abort\", abortAndFinalize);\n        });\n      }\n      let body = (0, import_node_stream2.pipeline)(response_, new import_node_stream2.PassThrough(), reject);\n      if (process.version < \"v12.10\") {\n        response_.on(\"aborted\", abortAndFinalize);\n      }\n      const responseOptions = {\n        url: request.url,\n        status: response_.statusCode,\n        statusText: response_.statusMessage,\n        headers,\n        size: request.size,\n        counter: request.counter,\n        highWaterMark: request.highWaterMark\n      };\n      const codings = headers.get(\"Content-Encoding\");\n      if (!request.compress || request.method === \"HEAD\" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {\n        response = new Response(body, responseOptions);\n        resolve(response);\n        return;\n      }\n      const zlibOptions = {\n        flush: import_node_zlib.default.Z_SYNC_FLUSH,\n        finishFlush: import_node_zlib.default.Z_SYNC_FLUSH\n      };\n      if (codings === \"gzip\" || codings === \"x-gzip\") {\n        body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createGunzip(zlibOptions), reject);\n        response = new Response(body, responseOptions);\n        resolve(response);\n        return;\n      }\n      if (codings === \"deflate\" || codings === \"x-deflate\") {\n        const raw = (0, import_node_stream2.pipeline)(response_, new import_node_stream2.PassThrough(), reject);\n        raw.once(\"data\", (chunk) => {\n          body = (chunk[0] & 15) === 8 ? (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createInflate(), reject) : (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createInflateRaw(), reject);\n          response = new Response(body, responseOptions);\n          resolve(response);\n        });\n        return;\n      }\n      if (codings === \"br\") {\n        body = (0, import_node_stream2.pipeline)(body, import_node_zlib.default.createBrotliDecompress(), reject);\n        response = new Response(body, responseOptions);\n        resolve(response);\n        return;\n      }\n      response = new Response(body, responseOptions);\n      resolve(response);\n    });\n    writeToStream(request_, request);\n  });\n}\nfunction fixResponseChunkedTransferBadEnding(request, errorCallback) {\n  const LAST_CHUNK = Buffer.from(\"0\\r\\n\\r\\n\");\n  let isChunkedTransfer = false;\n  let properLastChunkReceived = false;\n  let previousChunk;\n  request.on(\"response\", (response) => {\n    const { headers } = response;\n    isChunkedTransfer = headers[\"transfer-encoding\"] === \"chunked\" && !headers[\"content-length\"];\n  });\n  request.on(\"socket\", (socket) => {\n    const onSocketClose = () => {\n      if (isChunkedTransfer && !properLastChunkReceived) {\n        const error = new Error(\"Premature close\");\n        error.code = \"ERR_STREAM_PREMATURE_CLOSE\";\n        errorCallback(error);\n      }\n    };\n    socket.prependListener(\"close\", onSocketClose);\n    request.on(\"abort\", () => {\n      socket.removeListener(\"close\", onSocketClose);\n    });\n    socket.on(\"data\", (buf) => {\n      properLastChunkReceived = Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;\n      if (!properLastChunkReceived && previousChunk) {\n        properLastChunkReceived = Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;\n      }\n      previousChunk = buf;\n    });\n  });\n}\n\n// src/index.js\ninit_fetch_blob();\ninit_esm_min();\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  AbortError,\n  Blob,\n  FetchError,\n  FormData,\n  Headers,\n  Request,\n  Response,\n  isRedirect\n});\n/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n/*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n","/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","'use strict';\nconst os = require('os');\nconst tty = require('tty');\nconst hasFlag = require('has-flag');\n\nconst {env} = process;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false') ||\n\thasFlag('color=never')) {\n\tforceColor = 0;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = 1;\n}\n\nif ('FORCE_COLOR' in env) {\n\tif (env.FORCE_COLOR === 'true') {\n\t\tforceColor = 1;\n\t} else if (env.FORCE_COLOR === 'false') {\n\t\tforceColor = 0;\n\t} else {\n\t\tforceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);\n\t}\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(haveStream, streamIsTTY) {\n\tif (forceColor === 0) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (haveStream && !streamIsTTY && forceColor === undefined) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor || 0;\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\t// Windows 10 build 10586 is the first Windows release that supports 256 colors.\n\t\t// Windows 10 build 14931 is the first release that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream, stream && stream.isTTY);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: translateLevel(supportsColor(true, tty.isatty(1))),\n\tstderr: translateLevel(supportsColor(true, tty.isatty(2)))\n};\n","'use strict'\n\nvar net = require('net')\n  , tls = require('tls')\n  , http = require('http')\n  , https = require('https')\n  , events = require('events')\n  , assert = require('assert')\n  , util = require('util')\n  , Buffer = require('safe-buffer').Buffer\n  ;\n\nexports.httpOverHttp = httpOverHttp\nexports.httpsOverHttp = httpsOverHttp\nexports.httpOverHttps = httpOverHttps\nexports.httpsOverHttps = httpsOverHttps\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options)\n  agent.request = http.request\n  return agent\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options)\n  agent.request = http.request\n  agent.createSocket = createSecureSocket\n  agent.defaultPort = 443\n  return agent\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options)\n  agent.request = https.request\n  return agent\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options)\n  agent.request = https.request\n  agent.createSocket = createSecureSocket\n  agent.defaultPort = 443\n  return agent\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this\n  self.options = options || {}\n  self.proxyOptions = self.options.proxy || {}\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets\n  self.requests = []\n  self.sockets = []\n\n  self.on('free', function onFree(socket, host, port) {\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i]\n      if (pending.host === host && pending.port === port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1)\n        pending.request.onSocket(socket)\n        return\n      }\n    }\n    socket.destroy()\n    self.removeSocket(socket)\n  })\n}\nutil.inherits(TunnelingAgent, events.EventEmitter)\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, options) {\n  var self = this\n\n   // Legacy API: addRequest(req, host, port, path)\n  if (typeof options === 'string') {\n    options = {\n      host: options,\n      port: arguments[2],\n      path: arguments[3]\n    };\n  }\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push({host: options.host, port: options.port, request: req})\n    return\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createConnection({host: options.host, port: options.port, request: req})\n}\n\nTunnelingAgent.prototype.createConnection = function createConnection(pending) {\n  var self = this\n\n  self.createSocket(pending, function(socket) {\n    socket.on('free', onFree)\n    socket.on('close', onCloseOrRemove)\n    socket.on('agentRemove', onCloseOrRemove)\n    pending.request.onSocket(socket)\n\n    function onFree() {\n      self.emit('free', socket, pending.host, pending.port)\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket(socket)\n      socket.removeListener('free', onFree)\n      socket.removeListener('close', onCloseOrRemove)\n      socket.removeListener('agentRemove', onCloseOrRemove)\n    }\n  })\n}\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this\n  var placeholder = {}\n  self.sockets.push(placeholder)\n\n  var connectOptions = mergeOptions({}, self.proxyOptions,\n    { method: 'CONNECT'\n    , path: options.host + ':' + options.port\n    , agent: false\n    }\n  )\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {}\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        Buffer.from(connectOptions.proxyAuth).toString('base64')\n  }\n\n  debug('making CONNECT request')\n  var connectReq = self.request(connectOptions)\n  connectReq.useChunkedEncodingByDefault = false // for v0.6\n  connectReq.once('response', onResponse) // for v0.6\n  connectReq.once('upgrade', onUpgrade)   // for v0.6\n  connectReq.once('connect', onConnect)   // for v0.7 or later\n  connectReq.once('error', onError)\n  connectReq.end()\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head)\n    })\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners()\n    socket.removeAllListeners()\n\n    if (res.statusCode === 200) {\n      assert.equal(head.length, 0)\n      debug('tunneling connection has established')\n      self.sockets[self.sockets.indexOf(placeholder)] = socket\n      cb(socket)\n    } else {\n      debug('tunneling socket could not be established, statusCode=%d', res.statusCode)\n      var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode)\n      error.code = 'ECONNRESET'\n      options.request.emit('error', error)\n      self.removeSocket(placeholder)\n    }\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners()\n\n    debug('tunneling socket could not be established, cause=%s\\n', cause.message, cause.stack)\n    var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message)\n    error.code = 'ECONNRESET'\n    options.request.emit('error', error)\n    self.removeSocket(placeholder)\n  }\n}\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) return\n\n  this.sockets.splice(pos, 1)\n\n  var pending = this.requests.shift()\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createConnection(pending)\n  }\n}\n\nfunction createSecureSocket(options, cb) {\n  var self = this\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, mergeOptions({}, self.options,\n      { servername: options.host\n      , socket: socket\n      }\n    ))\n    self.sockets[self.sockets.indexOf(socket)] = secureSocket\n    cb(secureSocket)\n  })\n}\n\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i]\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides)\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j]\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k]\n        }\n      }\n    }\n  }\n  return target\n}\n\n\nvar debug\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments)\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0]\n    } else {\n      args.unshift('TUNNEL:')\n    }\n    console.error.apply(console, args)\n  }\n} else {\n  debug = function() {}\n}\nexports.debug = debug // for test\n","module.exports = require('./lib/tunnel');\n","'use strict';\n\nvar net = require('net');\nvar tls = require('tls');\nvar http = require('http');\nvar https = require('https');\nvar events = require('events');\nvar assert = require('assert');\nvar util = require('util');\n\n\nexports.httpOverHttp = httpOverHttp;\nexports.httpsOverHttp = httpsOverHttp;\nexports.httpOverHttps = httpOverHttps;\nexports.httpsOverHttps = httpsOverHttps;\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  return agent;\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  return agent;\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this;\n  self.options = options || {};\n  self.proxyOptions = self.options.proxy || {};\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;\n  self.requests = [];\n  self.sockets = [];\n\n  self.on('free', function onFree(socket, host, port, localAddress) {\n    var options = toOptions(host, port, localAddress);\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i];\n      if (pending.host === options.host && pending.port === options.port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1);\n        pending.request.onSocket(socket);\n        return;\n      }\n    }\n    socket.destroy();\n    self.removeSocket(socket);\n  });\n}\nutil.inherits(TunnelingAgent, events.EventEmitter);\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {\n  var self = this;\n  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push(options);\n    return;\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createSocket(options, function(socket) {\n    socket.on('free', onFree);\n    socket.on('close', onCloseOrRemove);\n    socket.on('agentRemove', onCloseOrRemove);\n    req.onSocket(socket);\n\n    function onFree() {\n      self.emit('free', socket, options);\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket(socket);\n      socket.removeListener('free', onFree);\n      socket.removeListener('close', onCloseOrRemove);\n      socket.removeListener('agentRemove', onCloseOrRemove);\n    }\n  });\n};\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this;\n  var placeholder = {};\n  self.sockets.push(placeholder);\n\n  var connectOptions = mergeOptions({}, self.proxyOptions, {\n    method: 'CONNECT',\n    path: options.host + ':' + options.port,\n    agent: false,\n    headers: {\n      host: options.host + ':' + options.port\n    }\n  });\n  if (options.localAddress) {\n    connectOptions.localAddress = options.localAddress;\n  }\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {};\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        new Buffer(connectOptions.proxyAuth).toString('base64');\n  }\n\n  debug('making CONNECT request');\n  var connectReq = self.request(connectOptions);\n  connectReq.useChunkedEncodingByDefault = false; // for v0.6\n  connectReq.once('response', onResponse); // for v0.6\n  connectReq.once('upgrade', onUpgrade);   // for v0.6\n  connectReq.once('connect', onConnect);   // for v0.7 or later\n  connectReq.once('error', onError);\n  connectReq.end();\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true;\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head);\n    });\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners();\n    socket.removeAllListeners();\n\n    if (res.statusCode !== 200) {\n      debug('tunneling socket could not be established, statusCode=%d',\n        res.statusCode);\n      socket.destroy();\n      var error = new Error('tunneling socket could not be established, ' +\n        'statusCode=' + res.statusCode);\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    if (head.length > 0) {\n      debug('got illegal response body from proxy');\n      socket.destroy();\n      var error = new Error('got illegal response body from proxy');\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    debug('tunneling connection has established');\n    self.sockets[self.sockets.indexOf(placeholder)] = socket;\n    return cb(socket);\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners();\n\n    debug('tunneling socket could not be established, cause=%s\\n',\n          cause.message, cause.stack);\n    var error = new Error('tunneling socket could not be established, ' +\n                          'cause=' + cause.message);\n    error.code = 'ECONNRESET';\n    options.request.emit('error', error);\n    self.removeSocket(placeholder);\n  }\n};\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) {\n    return;\n  }\n  this.sockets.splice(pos, 1);\n\n  var pending = this.requests.shift();\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function(socket) {\n      pending.request.onSocket(socket);\n    });\n  }\n};\n\nfunction createSecureSocket(options, cb) {\n  var self = this;\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    var hostHeader = options.request.getHeader('host');\n    var tlsOptions = mergeOptions({}, self.options, {\n      socket: socket,\n      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host\n    });\n\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, tlsOptions);\n    self.sockets[self.sockets.indexOf(socket)] = secureSocket;\n    cb(secureSocket);\n  });\n}\n\n\nfunction toOptions(host, port, localAddress) {\n  if (typeof host === 'string') { // since v0.10\n    return {\n      host: host,\n      port: port,\n      localAddress: localAddress\n    };\n  }\n  return host; // for v0.11 or later\n}\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i];\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides);\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j];\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k];\n        }\n      }\n    }\n  }\n  return target;\n}\n\n\nvar debug;\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments);\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0];\n    } else {\n      args.unshift('TUNNEL:');\n    }\n    console.error.apply(console, args);\n  }\n} else {\n  debug = function() {};\n}\nexports.debug = debug; // for test\n",null,"module.exports = require(\"assert\");","module.exports = require(\"buffer\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"net\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"process\");","module.exports = require(\"stream\");","module.exports = require(\"tls\");","module.exports = require(\"tty\");","module.exports = require(\"url\");","module.exports = require(\"util\");","module.exports = require(\"worker_threads\");","module.exports = require(\"zlib\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","const core = require('@actions/core')\nconst Heroku = require('heroku-client')\nconst { default: fetch } = require('node-fetch-cjs')\n\nconst domain = core.getInput('DOMAIN')\nconst subdomain = core.getInput('SUBDOMAIN')\nconst heroku = new Heroku({ token: core.getInput('HEROKU_API_TOKEN') })\nconst cloudflare = {\n  token: core.getInput('CLOUDFLARE_TOKEN'),\n  zone: core.getInput('CLOUDFLARE_ZONE'),\n}\n\nasync function run() {\n\n  // create heroku app\n  console.log('creating app', 'post', '/apps', { body: { name: subdomain } })\n  let app\n  try {\n    app = await heroku.post(\n      '/apps',\n      { body: { name: subdomain } }\n    )\n  } catch (error) {\n    console.error(error)\n    throw error\n  }\n\n  console.log('app created', app)\n\n  // add domain to heroku app\n  console.log('adding domain', 'post', `/apps/${app.name}/domains`, { body: { hostname: `${app.name}.${domain}`, sni_endpoint: null } })\n  let d\n  try {\n    d = await heroku.post(\n      `/apps/${app.name}/domains`,\n      { body: { hostname: `${app.name}.${domain}`, sni_endpoint: null } }\n    ) \n  } catch (error) {\n    console.error(error)\n    throw error\n  }\n  console.log('added domain', d)\n\n  // add CNAME record to namecheap\n  const { cname } = d\n  const args = [\n    `https://api.cloudflare.com/client/v4/zones/${cloudflare.zone}/dns_records`,\n    {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${cloudflare.token}`\n      },\n      body: JSON.stringify({\n        type: 'CNAME',\n        name: app.name,\n        content: cname,\n        ttl: 60\n      })\n    }\n  ]\n\n  console.log('adding cname record', args)\n  const response = await fetch(...args)\n  const result = await response.text()\n  console.log('added cname record', result)\n\n  core.setOutput('url', `http://${app.name}.${domain}`)\n}\n\nrun()\n"],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACvTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACxhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC5QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACtQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACnWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OASA;AACA;AACA;;;A;;;;;ACl3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;ACtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACnPA;;;A;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;ACvQA;;;A;;;;;;A;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;A","sourceRoot":""}